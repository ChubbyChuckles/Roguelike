COMBAT SYSTEM IMPLEMENTATION PLAN (Roadmap & Status) – Classless / Universal Access / Permadeath

Legend:
Done = Fully implemented & tests pass (or empirically verified in current runtime)
Partial = Some components implemented (details in parentheses)
X = Not started yet

Scope Overview:
A layered, deterministic, data‑driven combat framework with strictly classless design: every character can learn any skill, wield any weapon, and equip any armor weight. Balance is achieved through soft caps, encumbrance, stamina & poise tradeoffs, and adaptive diminishing returns instead of class restrictions. System supports melee / ranged / hybrid archetypes emergently, responsive input buffering, animation‑synchronized hitboxes, nuanced stamina–poise–encumbrance interactions, parry / dodge / guard defensive layers, contextual executions, status / proc hooks into the skill & effect pipeline, network‑ready deterministic sequencing, permadeath run integrity (death = total reset of power; only meta‑analytics persist), and tooling for authoring frame data & collision volumes.

PHASE 0. Current Baseline (Done)
0.1 Player attack finite state machine (Idle → Windup → Strike → Recover) (Done)
0.2 Dynamic per‑phase timers with combo speed scalar (Done)
0.3 Basic combo counter with damage scaling & speed acceleration (Done)
0.4 Stamina pool with per‑attack cost & regen delay gating (Done)
0.5 Input buffering during non‑idle phases (stores next attack) (Done)
0.6 Early cancel on hit‑confirm (Strike → Recover advance) (Done)
0.7 Hitstop injection (time dilation via global timer) (Done)
0.8 Frame‑gated strike activation (animation frame mask + permissive fallback) (Done)
0.9 Reach / arc calculation with directional filtering & combo scaling (Done)
0.10 Critical hit chance & crit damage multiplier pipeline (Done)
0.11 Knockback application with crit scaling & cap (Done)
0.12 Damage number spawning (crit-aware) (Done)
0.13 Strength buff integration into damage (buff query) (Done)
0.14 Basic buffered chain cost reduction (subsequent stamina cost lower) (Done)
0.15 Deterministic fallback for tests (frame override, permissive mask) (Done)
0.16 Simple early cancel threshold logic (percentage of strike) (Done)
0.17 Classless openness baseline (no equipment or skill slot gating implemented yet) (Done)
0.18 Permadeath core rule (on death, character state discarded; only session analytics retained) (Done)

PHASE 1. Core Model Expansion (Classless Universal Attack Data)
 1.1 WeaponArchetype enum & data: (light, heavy, thrust, ranged, spell_focus) (Done)
 1.2 AttackDef struct: startup_ms, active_windows[], recovery_ms, stamina_cost, poise_damage, poise_cost, cancel_tags (Partial: struct + windows + costs + added poise_cost & cancel_flags fields; logic unimplemented)
 1.3 Data-driven attack registry: static table → external config later (no class gates; universal query) (Partial: static in-memory chains, external file loader pending)
 1.4 Multiple attack branches (light chain, heavy chain, directional variants) (Partial: linear chains authored; directional variants pending)
 1.5 Per-attack hit properties: damage_type, base_damage, scaling_coeffs (Partial: damage_type + STR/DEX/INT coeffs + status buildup fields (bleed/frost) scaffolded + scaling application integrated into damage calc + test_combat_scaling_coeffs passing; status buildup application pending)
 1.6 Distinguish buffered_next vs queued_branch (directional / heavy) (Partial: archetype branch queue implemented; directional branch inputs pending)
 1.7 Tests: archetype timing consistency, branch selection determinism, universal access invariants (no forbidden weapon) (Done: test_combat_attack_registry)

PHASE 1A. Temporal & Animation Sync Enhancements
1A.1 Fine-grained frame data authoring (ms → frames at runtime tick) (Done: centralized frame span computation + static cache for authored windows; helper rogue_attack_window_frame_span now cached)
1A.2 Multi-hit active windows (e.g., sweep phases) (Partial: engine support + data for light_3 & heavy_2 multi-window splits + processed_window_mask duplicate prevention + unit tests `test_combat_multi_hit`, `test_combat_heavy_multi_window`; per-window damage_mult field; remaining: external data authoring tool)
1A.3 Cancellable window flags (on_hit, on_whiff, on_block) (Done: global + per-window override resolution; hit/whiff/block early cancel logic + recovery late-chain grace window; pending: additional flag types for parry/dodge & hyper armor frames)
1A.4 Whiff cancel partial credit (reduced window vs on_hit) (Partial: whiff_cancel_pct enforced + test; archetype-specific tuning pending)
1A.5 Animation event injection (begin_active, end_active, fx triggers) (Partial: per-window begin/end events emitted to ring buffer + unit test `test_combat_events`; added API rogue_combat_consume_events (non-destructive to masks); remaining: FX/SFX dispatch layer & external authoring integration)
1A.6 Drift-resistant timing (accumulator correcting float error >1ms) (Done: double accumulator + micro-step unit test)
1A.7 Tests: cancel window edges, multi-hit ordering, drift bounds (Done: multi-hit ordering + duplicate prevention + heavy_2 triple-window test + overlapping window boundary test)
	- heavy_2 triple-window unit test (`test_combat_heavy_multi_window`) covering sequential window damage + BEGIN/END event emission (3 windows => 6 events).
	- Overlap & boundary semantics test (`test_combat_window_boundary`) verifies inclusive/exclusive edges & overlapping window (0-50 overlaps 40-80) processes only new windows; ensures no duplicate damage or missing events.
	- Helper `rogue_attack_window_frame_span` now cached (static frame cache) for future external frame authoring.
	- Fixed combo scaling test regression earlier by resetting processed_window_mask when strike_time resets (enables repeated isolated measurement without multi-hit gating).

PHASE 2. Damage & Mitigation Pipeline
2.1 Damage types (physical, bleed, fire, frost, arcane, poison, true) (Done: enum RogueDamageType added; attack defs map to types)
2.2 Defense stats: armor (physical), resist(type), flat & percent reduction (Done: dedicated physical percent resist field (resist_physical) applied after armor; elemental resist percent applied; added diminishing returns curve for physical percent resist `eff = p - (p*p)/300` (p capped 0..90, effective capped <=75) to taper stacking efficiency; future status-specific resists deferred to later effect/status phases.)
2.3 Penetration model (flat + percent; order: flat→(armor reduction)→percent→mitigation) (Done: applied pre-mitigation in strike; flat then percent of original armor; test `test_combat_penetration` validates ordering)
2.4 Crit layering refactor: pre- vs post-mitigation toggles; additive vs multiplicative stacking audit (Done: g_crit_layering_mode introduced (0=pre(default),1=post); player strike rolls crit and applies per mode; damage events carry crit flag; unit test `test_combat_crit_layering` validates raw consistency & ordering)
2.5 Minimum damage floor logic (post mitigation) (Done: enforced floor >=1 in rogue_apply_mitigation_enemy)
2.6 Overkill capture & execution triggers (Done: execution logic added (low health <=15% or overkill >=25% max health) producing execution flag in damage events; unit test `test_combat_execution` validates low-health, overkill, and non-execution cases.)
2.7 Damage event struct (for logging, replay, network) (Advanced -> Expanded: events emitted per hit; ring buffer 64; added crit & execution flags, global total counter, consumer APIs `rogue_damage_events_snapshot`, `rogue_damage_events_clear`; tests `test_combat_damage_events`, `test_combat_crit_layering`, `test_combat_execution` exercise emission, crit layering, execution flags.)
2.8 Tests: mitigation order correctness, penetration stacking, crit vs armor invariants (Expanded: `test_combat_mitigation`, `test_combat_penetration`, `test_combat_crit_layering`, `test_combat_execution`, `test_combat_damage_events`, `test_combat_phys_resist_curve` cover armor->phys resist ordering, elemental resist, damage floor, penetration ordering, crit layering invariants, execution trigger flags, event emission integrity, and monotonic diminishing returns behavior of physical resist curve.)

PHASE 3. Stamina, Poise, Encumbrance & Hyper Armor
3.1 Separate Stamina vs Guard Meter vs Poise (temporary stability buffer) (Done: added guard_meter/poise fields + max values to player & enemy structs; initialized and clamped in player init/recalc; basic presence & bounds test `test_combat_phase3_guard_poise`.)
3.2 Encumbrance rating (derived from total equipped weight vs capacity) affecting: stamina regen, movement speed (Done: added encumbrance, capacity, tier calc to player; movement speed scaled by tier (0 light=1.0,1 med=0.9,2 heavy=0.75,3 overloaded=0.55); test `test_combat_phase3_encumbrance` validates tier progression impact on stamina regen ordering. Future: dodge i-frames & roll distance adjustments deferred.)
3.3 Poise damage accumulation & stagger threshold (Done: applied per-attack poise_damage to enemy poise; depletion triggers stagger flag + timer with partial poise regen on recovery; test `test_combat_phase3_poise_stagger` validates depletion & recovery.)
3.4 Hyper armor frames (poise ignore) authoring per attack window (Done (plumbing): added window flag `ROGUE_WINDOW_HYPER_ARMOR` and exposed current_window_flags; flag not yet authored in data table so immunity behavior pending incoming poise damage pipeline; test `test_combat_phase3_hyper_armor` asserts flag plumbing.)
3.5 Dynamic stamina tax scaling with encumbrance tiers (light/med/heavy/overloaded) (Done: regen multiplier applied in combat update: 1.0 / 0.92 / 0.80 / 0.60; verified via `test_combat_phase3_encumbrance` decreasing regen values.)
3.6 Soft cap on stacking defensive weight: diminishing returns curve on effective damage negation (Done: implemented combined physical reduction soft cap after armor+percent resist with threshold=65%, slope=0.45 for excess, max=85%; respects raw>=100 guard. Test `test_combat_phase3_def_softcap` validates cap behavior.)
3.7 Tests: encumbrance tier transitions, stamina regen under load, i-frame reduction bounds, DR curve monotonicity (Partial: added `test_combat_phase3_guard_poise`, `test_combat_phase3_encumbrance`, `test_combat_phase3_poise_stagger`, `test_combat_phase3_hyper_armor`, `test_combat_phase3_def_softcap`; i-frame & future defensive weight curve refinements and actual hyper armor immunity tests pending.)
3.8 Guard (blocking) state: directional reduction cone + chip damage (Done: implemented `rogue_player_begin_guard`, `rogue_player_apply_incoming_melee` with frontal cone dot>=0.25, chip damage 20%, guard meter drain holding + on block, integration in enemy melee; test `test_combat_phase3_guard_block` covers frontal block, perfect guard, chip, rear attack bypass.)
3.9 Perfect guard (parry timing window) producing posture break on attacker (Done: perfect window first 140ms of guard; perfect guard negates damage, refunds guard meter, restores poise bonus; test asserts perfect behavior; future attacker posture impact deferred.)
3.10 Poise regen curve (delay + accelerated early regen) (Done: quadratic early missing% scaling in `rogue_player_poise_regen_tick`, delay reset on taking damage; test `test_combat_phase3_poise_regen_curve` validates stronger low-poise recovery.)
3.11 Tests: stagger on threshold, hyper armor immunity, guard cone edge, perfect guard frame tolerance (Done: Added `test_combat_phase3_hyper_armor_immunity` (poise ignore), `test_combat_phase3_guard_block` (cone + perfect window), guard cone edge precision test `test_combat_phase3_guard_cone_edge`, stagger threshold precision test `test_combat_phase3_poise_stagger_precision`. Authored hyper armor window on heavy_2 mid window (flags now include `ROGUE_WINDOW_HYPER_ARMOR`) with strike pipeline enabling poise ignore during that window. Perfect guard tolerance implicitly covered by immediate vs post-window tests; future jitter fuzzing optional.)

PHASE 4. Hit Reactions & Crowd Control Integration
4.1 Reaction categories: light flinch, medium stagger, heavy knockdown, launch (Done: player struct extended with reaction_type, reaction_timer_ms; categories implemented (1..4) with duration table)
4.2 Mapping damage/poise thresholds to reaction (Done: raw damage thresholds 25+ => flinch, 80+ => knockdown if no prior poise-triggered stagger; poise depletion triggers stagger reaction_type=2; launch reserved reaction_type=4 not yet triggered by thresholds)
4.3 Invulnerability / i-frame layering (dodge, roll, parry) (Done: added iframes_ms, incoming melee early-out returns 0 damage when >0; test covers immunity)
4.4 CC integration with skill system (stun, root, slow, disarm) (Done: added cc_* timers & speed/attack gating; stun & disarm suppress attack buffering; root blocks movement only; slow scales move speed (cap 95%); timers decrement each controller update.)
4.5 Reaction cancel windows & DI (directional influence) (Done: added per-reaction cancel window fractions (light 40-75%, stagger 55-85%, knockdown 60-80%, launch 65-78%), early cancel API `rogue_player_try_reaction_cancel`; directional influence accumulation with per-reaction DI caps (0.35/0.55/0.85/1.0) and circular clamp; player struct stores original total duration & DI accumulators; durations reset on new reaction.)
4.6 Tests: reaction selection determinism, i-frame overlap protection, DI effect bounds (Expanded: selection & i-frame in `test_combat_phase4_reactions`; CC gating in `test_combat_phase4_cc`; `test_combat_phase4_reaction_cancel_di` (cancel window & DI clamp); new `test_combat_phase4_iframe_overlap` validating non-stacking i-frame grant (max replacement) and immunity during remaining frames. Remaining optional: launch aerial DI nuance.)

PHASE 5. Spatial Targeting & Hit Detection
5.1 Hitbox volume types: capsule, swept arc, multi-segment chain, projectile spawn descriptors (Done: Added `hitbox.h/.c` with POD primitives + union `RogueHitbox`; implemented point intersection for capsule (segment distance), arc (angle & radial band with wrap handling + optional inner_radius for ring sectors), chain (capsule per-segment), and descriptive projectile spawn descriptor (angles computed evenly across spread). Provided builder helpers + chain mutator + projectile angle helper. Added unit test `test_combat_phase5_hitbox_primitives` covering inclusion/exclusion cases, inner radius hole, chain segment coverage, and projectile spread endpoints + center. No gameplay integration yet—pure primitives foundation for 5.2 authoring & 5.3 broadphase.)
5.2 Authoring tool: JSON or binary layout for hitbox frames (Done: Implemented lightweight JSON subset parser `hitbox_load.c` supporting array of hitbox objects (capsule/arc/chain/projectile_spawn) with numeric fields & points arrays. Provides APIs `rogue_hitbox_load_sequence_from_memory` and `_file`. Robust to unknown keys for forward extensibility. Unit test `test_combat_phase5_hitbox_authoring_broadphase` validates parsing of 4 mixed primitives, field population, chain point count, and projectile spread angles.)
5.3 Broadphase culling (grid / BVH reuse) for candidate entities (Done: Added AABB derivation per hitbox primitive + helper `rogue_hitbox_collect_point_overlaps` performing coarse AABB prune then precise narrow-phase point test. Unit test covers inclusion of interior points and exclusion of out-of-range & just-outside-radius points. Ready for future integration with enemy arrays / spatial grid; current implementation deterministic & allocation-free.)
5.4 Friendly fire & team filter mask (Done: added team_id to player/enemy structs; strike loop skips same-team; unit test `test_combat_phase5_team_obstruction` validates ally immunity.)
5.5 Terrain interaction: clank vs walls, obstruction reduces damage (Done (attenuation): DDA tile sampling between player & target; blocking tile applies 60% damage scaling; integrated into strike damage pre-mitigation; covered by obstruction portion of `test_combat_phase5_team_obstruction`. Future: clank SFX/hook placeholder.)
5.6 Lock-on subsystem (optional assist) with soft magnetize logic (Done: added lock_on.c/h; acquisition prioritizes nearest + facing bias, angular cycle ordering with 180ms cooldown, direction override updating facing; validation drops target on death or leaving radius (1.25x hysteresis). Integrated into strike directional vector.)
5.7 Tests: multi-target consistency, obstruction damping, lock-on switch latency (Done: `test_combat_phase5_lock_on` (acquire/cycle/cooldown/direction/invalidation) + `test_combat_phase5_lock_on_obstruction_latency` (cycle latency + obstruction ratio 55-65%) + `test_combat_phase5_lock_on_multitarget` (angular ordering forward/back cycle wrap & backward verification). Phase 5 spatial targeting lock-on test suite complete.)

PHASE 6. Advanced Offensive & Defensive Mechanics (Classless Tradeoffs)
6.1 Charged attacks (hold to scale damage/poise with nonlinear curve) (Done: added charging state to combat struct, begin/tick/progress APIs; curve: multiplier = 1 + clamp(t/800ms,0..1)*1.5 capped 2.5x with overcharge ceiling at 1600ms; multiplier consumed on next strike then reset; unit test `test_combat_phase6_charge_and_dodge` validates baseline vs fully charged (~2.5x) damage and single-use consumption.)
6.2 Aerial attacks & landing lag differentiation (Done: aerial flag consumption grants +20% damage and adds 120ms landing lag to recovery; placeholder airborne setter API; full jump system integration deferred to movement phase.)
6.3 Dodge roll with i-frames & stamina cost scaling by encumbrance load (Done (baseline): implemented `rogue_player_dodge_roll` with stamina cost 18, grants 400ms i-frames (non-stacking), slight poise restore (+10 capped), facing update via dir param; disallowed during strike or reaction. Future: scale cost/i-frame duration by encumbrance tier. Tested in `test_combat_phase6_charge_and_dodge` (stamina deduction, i-frame grant, low-stamina failure path).)
6.4 Backstab / positional crit detection (rear cone + proximity + unaware flag) (Done: detection + automatic 1.75x one-shot damage multiplier applied on next strike via pending flag; cooldown 650ms; validated by extended multiplier test.)
6.5 Parry → Riposte chain (timing + special damage window) (Done: parry window 160ms, successful parry grants i-frames + riposte window 650ms. Consuming riposte now applies 2.25x pending multiplier to next strike. Tests cover parry success & damage escalation.)
6.6 Guard break follow-up guaranteed crit window (Done (player-side): guard break setter primes riposte-style window + 1.50x damage multiplier and guarantees next strike crit (force flag) while window active; consume API clears readiness. Enemy guard depletion trigger still to be wired in future AI/defense integration phase.)
6.7 Projectile deflection / reflection (parry / perfect guard) (Done (baseline): reflection direction logic in place; future projectile entity mutation & reflected damage application pending.)
6.8 Tests: parry timing jitter tolerance, backstab angle threshold, charge curve scaling accuracy (Expanded: added extended multiplier test `test_combat_phase6_backstab_guardbreak_riposte_bonus` validating backstab 1.75x, riposte 2.25x, guard-break 1.5x + forced crit; earlier tests cover charge, dodge, parry baseline, deflect, aerial landing lag placeholder.)

PHASE 7. Weapons, Armor & Encumbrance Styles
7.1 Data-driven weapon definitions: base stats, scaling letters (open to all) (Done (initial in-memory): `weapons.c/h` table with base damage, STR/DEX/INT scales, stamina & poise multipliers, durability max. Future: external data + letter grade mapping.)
7.2 Armor weight classes (light/med/heavy) with continuous encumbrance influencing mobility & regen (Deferred: basic encumbrance already implemented Phase 3; detailed armor class differentiation still X.)
7.3 Stance modifiers (aggressive, balanced, defensive) altering frame data & stamina costs (Done (damage/stamina/poise scalars): aggressive +15% dmg/+15% stamina/+10% poise dmg; defensive -10% dmg/-15% stamina/-5% poise dmg; balanced neutral. Frame data adjustments deferred.)
7.4 Infusions (elemental / status) altering damage split & scaling (X)
7.5 Weapon familiarity curve (usage-based soft bonuses; capped low to avoid pseudo-classes) (Done (basic): familiarity accumulates usage_points from damage; grants up to +10% damage soft-capped; test validates growth.)
7.6 Durability / sharpness (affects damage & stagger over time) (Partial: durability tracked & decremented per hit; effect on damage not yet applied; sharpening / repair mechanics pending.)
7.7 Tests: infusion damage redistribution, stance frame adjustments, familiarity soft cap enforcement, encumbrance mobility curve (Partial: Added `test_combat_phase7_weapon_stance_familiarity` covering stance damage delta, familiarity increase, durability decrement; remaining infusion & frame timing tests pending future feature completion.)

PHASE 8. Effect / Proc / Skill Integration
8.1 On-hit proc hooks (trigger effect specs) (X)
8.2 Life / resource leech resolution order (post-mitigation) (X)
8.3 Conditional procs (crit-only, backstab-only, stagger-only) (X)
8.4 Damage over time bridging (weapon applies DOT on proc) (X)
8.5 Snapshot vs dynamic scaling flags for attack-sourced effects (X)
8.6 Tests: proc ICD enforcement, leech cap, conditional trigger gating (X)

PHASE 9. AI Combat Behaviors
9.1 Behavior modules: approach, circle-strafe, feint, commit, disengage (X)
9.2 Telegraph design (windup visuals synced to player frame data) (X)
9.3 Difficulty scaling curves (reaction time clamp, feint frequency) (X)
9.4 Adaptive AI (responds to player dodge direction bias) (X)
9.5 Group tactics (role assignment: pressure, flank, support) (X)
9.6 Tests: telegraph advance timing, group spacing invariants, adaptive response latency (X)

PHASE 10. Networking & Determinism
10.1 Deterministic attack event sequence hashing (X)
10.2 Authoritative simulation with client-side prediction of attack phases (X)
10.3 Rollback window for parry/dodge (input delay compensation) (X)
10.4 Input compression & delta stream (X)
10.5 Latency-aware hit validation (rewind entity transforms) (X)
10.6 Tests: hash mismatch detection, rollback convergence, latency envelope pass (X)

PHASE 11. Camera, VFX & Feedback
11.1 Layered screen shake categories (light, heavy, finisher) (X)
11.2 Dynamic FOV & subtle time dilation on finishers (X)
11.3 Weapon trail & hit spark effect pooling (X)
11.4 Audio layering: whoosh, impact, crit, stagger, parry ring (X)
11.5 Contextual rumble pattern mapping (controller) (X)
11.6 Tests: effect pool reuse, shake stacking clamp (X)

PHASE 12. Analytics & Telemetry
12.1 Per-attack usage & hit/miss rates (X)
12.2 Reaction timing histogram (parry, dodge, block windows) (X)
12.3 Stamina efficiency metrics (damage per stamina) (X)
12.4 Poise break frequency & source attribution (X)
12.5 Export snapshot JSON for balancing dashboards (X)
12.6 Tests: metric accumulation accuracy, export round-trip (X)

PHASE 13. Tooling & Authoring
13.1 Frame data editor (GUI) with timeline scrubbing (X)
13.2 Hitbox visualizer overlay (live & playback) (X)
13.3 Combo script tester (auto-run sequences measuring DPS & stamina curve) (X)
13.4 Golden master regression harness (captures authoritative event streams) (X)
13.5 Static analyzer: detect unreachable cancel routes / overlapping windows (X)
13.6 Tests: editor serialization diff, analyzer false positive rate bounds (X)

PHASE 14. Performance & Memory
14.1 Object pool for transient hit events & damage numbers (X)
14.2 SoA layout for active hitboxes (minimizes cache misses) (X)
14.3 Broadphase acceleration structure reuse (grid / BVH) (X)
14.4 SIMD batch distance / penetration checks (X)
14.5 Micro-profiler zones for each combat phase & subsystem (X)
14.6 Tests: stress (500 concurrent hitboxes) under frame budget, allocator reuse (X)

PHASE 15. Security / Anti-Cheat / Validation & Permadeath Integrity
15.1 Attack rate clamp vs authored frame data (X)
15.2 Deterministic signature of attack & run event sequence (X)
15.3 Invalid state detection (e.g., simultaneous hyper armor & stagger) (X)
15.4 Server authoritative crit & penetration rolls (X)
15.5 Tamper-resistant damage pipeline (hash chain) (X)
15.6 Permadeath death-record hash (validates death legitimacy; prevents rollback/save‑scum) (X)
15.7 Run seed + event digest exported on death for analytics (X)
15.8 Tests: death hash stability, rollback detection, duplicate run seed rejection (X)

PHASE 16. Balancing, Live Tuning & Classless Soft Caps
16.1 Hot-reloadable attack & weapon data (X)
16.2 Adaptive difficulty: adjust AI feint & punish rate (X)
16.3 Global soft caps (diminishing returns curves) for stacking unrelated offensive/defensive stats to curb single-run runaway in absence of class limits (X)
16.4 Per-weapon & cross-loadout KPI dashboard (DPS, hit rate, stamina efficiency, time-to-stagger, mobility index) (X)
16.5 Elastic tuning sandbox (simulate distribution of loadout combinations) (X)
16.6 Auto-suggest balance deltas (heuristics / statistical outlier detection) (X)
16.7 Tests: soft cap curve monotonicity, outlier detection false positive ceiling (X)

PHASE 17. Polish, Accessibility & Permadeath UX
17.1 Aim assist cone (toggle) & dynamic magnetization for gamepad (X)
17.2 Customizable combo mappings / remap UI (X)
17.3 Colorblind-friendly telegraph palette & alternative impact cues (X)
17.4 Haptic pattern library for reaction types (X)
17.5 Reduced-motion settings (limit screenshake / flashes) (X)
17.6 Permadeath death recap panel (last N damage events, stamina/poise timeline) (X)
17.7 Post-death analytics export & share code (X)
17.8 Tests: death recap accuracy, export validity (X)

PRIORITY NEAR-TERM SUBSET
- Phase 1 (1.1 – 1.7): Core universal attack data & branching
- Phase 1A (1A.1 – 1A.7): Precise timing & cancel windows
- Phase 3 (encumbrance + poise integration early for tradeoffs)
- Phase 6 (parry, dodge roll baseline) for defensive depth
- Phase 2 (damage pipeline) to enable soft caps & mitigation clarity
- Phase 15 (death hash + run signature minimal subset) for permadeath integrity

NOTES
- No hard class gates: balance relies on stamina, encumbrance, poise, soft caps, and opportunity cost of hybridizing gear.
- Deterministic ordering: attack event IDs increment monotonically; damage & death events hashed for replay & death validation.
- Floats periodically renormalized to prevent drift in long survival sessions; permadeath means runs can be long but finite.
- Hooks to skill/effect system (Phase 8) unify proc, DOT, CC application irrespective of weapon/armor choice.
- AttackDef arrays private; only opaque handles exposed. Gear & infusion selection maps to AttackDef views (no subclass logic).
- Micro-bench harness early (phases 1A/5) for 1000 hitbox stress at target frame budget.
- Struct padding reserved for network & anti-cheat flags (run hash bits, death cause code).
- Analytics persists across deaths only as meta (no power carryover) preserving roguelike integrity.
- Soft cap & diminishing returns curves must be monotonic & slope‑continuous (C1) to avoid abrupt meta shifts.
