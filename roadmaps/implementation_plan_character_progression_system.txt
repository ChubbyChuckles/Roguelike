CHARACTER VERTICAL PROGRESSION SYSTEM IMPLEMENTATION PLAN (Roadmap & Status)

Legend:
Done = Fully implemented & tests pass
Partial = Some components implemented (details in parentheses)
X = Not started yet
Optional = Stretch / future wave

Scope Overview:
Design and implement a deep, extensible vertical progression framework covering infinite XP & leveling (no hard cap), attributes, passive & active skill acquisition via a maze-based skill graph, mastery (per-skill usage growth), universal skill learning (no classes / ascendancies), perpetual advancement scaling (soft diminishing returns instead of post-cap switch), synergy with equipment/skills/affixes, performance-friendly stat aggregation, deterministic & auditable growth, anti-grind safeguards, and rich analytics. Constraints: single character per account, no stash/bank, infinite inventory stacking, no seasonal resets. All players can eventually unlock every skill; specialization emerges from stat distribution, path efficiency through the maze, and investment sequencing.

FOUNDATIONAL ASSUMPTIONS / CURRENT STATE
- Skills framework & cooldown / cost logic (Done)
- Equipment stat & affix budget governance (Done)
- Persistence & integrity hashing chain (Done)
- Inventory infinite stacking + material ledger (Partial)
- Combat stat calculation pipeline (Partial – assumed basic stats exist)
- Maze skill configuration file exists (`assets/skill_maze_config.json`) providing structural seed for graph integration.

PHASE 0. Baseline Audit & Stat Taxonomy (Done)
0.1 Enumerate current combat stats (attack_power, spell_power, crit_chance, etc.) (Done – mapped existing: strength,dexterity,vitality,intelligence, crit_chance, crit_damage, resist set, derived dps/ehp indices)
0.2 Define canonical stat taxonomy (primary, derived, rating, modifier) (Done – see progression_stats.[ch] ranges 0-99/100-199/200-299/300-399 with 400-499 reserved)
0.3 Gap analysis vs planned progression layers (talents, mastery, ascendancy) (Done – placeholders added for ratings & modifiers + sustainability index reserved)
0.4 Reserve ID ranges for future stats to avoid collisions (Done – documented in header comment & enforced by test)
0.5 Tests: taxonomy uniqueness, stable serialized order (Done – unit test test_progression_phase0_taxonomy verifies uniqueness, ordering, id->category mapping & fingerprint stability)

PHASE 1. Infinite XP & Level Core (Done)
1.1 Level scaling function definition (rogue_xp_to_next_for_level / rogue_xp_total_required_for_level) – implemented in `progression_xp.c` with no hard cap (Done)
1.2 Adaptive multi-component curve (linear + quad + pow^2.1 + log) delivering smooth early growth, accelerating mid, compressed late (Done)
1.3 XP sources hook: kill XP already integrates via player_assets; future sources can call safe add (Documented) (Done initial)
1.4 Catch-up modifier (tanh-based up to 1.75x) via `rogue_xp_catchup_multiplier` (Done)
1.5 Overflow safety: 64-bit accumulator `xp_total_accum` + `rogue_xp_safe_add` saturating (Done)
1.6 Tests: monotonicity, cumulative total consistency, catch-up scaling, overflow protection in `test_progression_phase1_xp_curve` (Done)

PHASE 2. Attribute Allocation Layer (Done)
2.1 Primary attributes set (Strength, Dexterity, Vitality, Intelligence) – existing player stats leveraged (Done)
2.2 Allocation points per level (+3) already granted in player_progress; exposed grant API (Done)
2.3 Re-spec token mechanism with journal hash (simplified rolling hash) in `progression_attributes.c` (Done)
2.4 Derived formulas placeholder (current derived recalcs already in player_recalc; formal mapping deferred to rating phase – marked Done for baseline integration)
2.5 Tests: spend/respec, fingerprint change, unspent delta invariants (`test_progression_phase2_attributes`) (Done)

PHASE 3. Rating & Diminishing Returns System (Done)
3.1 Rating categories (crit_rating, haste_rating, avoidance_rating) (Done)
3.2 DR curves (multi-band concave) (Done)
3.3 Aggregation order (base -> rating -> multiplicative) (Done)
3.4 Visualization helper (effective %) (Done)
3.5 Tests: monotonic mapping, curve continuity & hard caps (Done)

PHASE 4. Maze Skill Graph Framework (Done)
4.1 Maze graph ingestion from `skill_maze_config.json` (nodes: geometric positions & edges). Implemented wrapper `progression_maze.[ch]` building on `skill_maze` generator, adding meta layer.
4.2 Procedural gap filling & difficulty tagging: Added ~5% optional leaf branches (flag bit0) near outer/high-ring nodes; high inner-degree nodes flagged difficulty (bit1). Counts tracked.
4.3 Pathfinding utilities: Implemented `rogue_progression_maze_shortest_cost` (Dijkstra) using node point cost weights.
4.4 Node gating predicates: Derived level & attribute requirements from ring index; `rogue_progression_maze_node_unlockable` enforces.
4.5 Tests: `test_progression_phase4_maze` validates build success, root unlockability, gating failure at low level for high ring, path cost sanity, orphan audit (non-negative).

PHASE 5. Skill & Passive Unlock Integration (Done)
5.1 Unified effect DSL (passive stat changes implemented; active skill modifier hook reserved) (Done – `rogue_progression_passives_load_dsl` parses STR+5 etc.)
5.2 Runtime compile to dispatch tables (Done – line DSL compiled into compact effect & node effect tables)
5.3 Unlock transaction journal (node_id,timestamp) hashed (Done – FNV-1a rolling hash in `journal_append` + `rogue_progression_passives_journal_hash`)
5.4 Precomputed passive snapshot & incremental diff application (Done – accum array `g_passive_stat_accum` updated on unlock)
5.5 Hot reload of maze with migration mapping (Done – `rogue_progression_passives_reload` replays journal & validates hash)
5.6 Tests: DSL parse, stat totals, duplicate unlock prevention, hash change & reload invariants (`test_progression_phase5_passives` prints PROG_P5_OK) (Done)

PHASE 6. Mastery System
6.1 Mastery XP separate track (earns via sustained skill usage) (Done - minimal per-skill mastery XP module added: `src/core/progression_mastery.[ch]` with deterministic rank thresholds and unit test `tests/unit/test_progression_mastery.c`)
6.2 Mastery levels unlocking minor passive rings (Done - distinct skill rank >=5 contributes ring point via `rogue_mastery_minor_ring_points`)
6.3 Per-skill mastery bonus scaling tiers (Done - bracketed scalar 1.01→1.20 by rank thresholds in `rogue_mastery_bonus_scalar`)
6.4 Decay or plateau mechanic to prevent runaway specialization (Done - inactivity grace 60s then geometric surplus decay windows 10% each; toggle `rogue_mastery_set_decay`)
6.5 Tests: mastery XP distribution fairness, decay correctness (Done - `test_progression_phase6_mastery_extended` validates rank growth, ring points, bonus ordering, decay loss)

PHASE 7. Expanded Passive Rings (Former Ascendancy Slot Replacement)
7.1 Unlockable passive ring layers (outer maze expansions at milestone levels) (Done – milestone function + dynamic expansion API `rogue_progression_maze_expand` with procedural node placement & adjacency rebuild; test covers ring count growth)
7.2 Keystone-like universal nodes (powerful effects balanced by cost & prerequisite chain length) (Done (scaffold) – heuristic keystone flagging + query helpers; effect payload & balancing costs to follow in Phase 9 integration)
7.3 Anti-stack safeguards (budget & diminishing synergy coefficients) (Done – implemented per-category (offense/defense/utility) diminishing for keystones: coefficient = 1/(1+0.15*(k-1)), classification heuristic from effect mix, accumulator widened to double, journal replay resets counts; unit test `test_progression_phase7_antistack` verifies reduced incremental STR and independence across categories + count APIs.)
7.4 Visualization layering (zoomable maze out to ring expansions) (Done – added ring layer export & projection helpers: `rogue_progression_maze_layers`, `rogue_progression_maze_project`, and ASCII overview generator `rogue_progression_maze_ascii_overview` enabling UI to render concentric scalable layout; supports dynamic expansions. Unit test `test_progression_phase7_visualization` validates layer count == total rings, monotonic radii, projection bounds, and ASCII summary integrity.)
7.5 Tests: ring integration, keystone cost scaling integrity (Done (initial) – `test_progression_phase7_rings` validates milestones, expansion, keystone invariants)

PHASE 8. Perpetual Scaling Layer
8.1 Continuous micro-node progression (minor stat nodes always available) (Done – allowance function level/2 + level/25 milestone; spend API with cap by level.)
8.2 Diminishing power function (aggregate_stat_bonus(level) uses sublinear growth) (Done – per-node contribution BASE/(1+CURV*i) summed + level scalar (1-exp(-L/LAMBDA))^ALPHA).
8.3 Global balancing coefficient adjustable server-side (future-proof) (Done – setter/getter + clamp 0.1–5.0, inflation guard clamps 0.85–1.15 range).
8.4 Inflation guard telemetry integration (adjust coefficient if median TTK drifts) (Done – proportional adjust function `rogue_perpetual_inflation_adjust`).
8.5 Tests: sublinear asymptote verification, no runaway accumulation (Done – `test_progression_phase8_perpetual` validates allowance, diminishing increments, sublinear 100→200 ratio <2x.)

PHASE 9. Synergy With Equipment & Skills
9.1 Unified modifier combination order (equipment -> passives -> mastery -> micro) (Done – implemented layered aggregation helper `rogue_progression_layered_damage` applying multiplicative chain in canonical order.)
9.2 Cap enforcement (hard & soft) for key stats (crit, cooldown_reduction) (Done – added crit soft cap 60% with diminishing above + hard cap 95%; cooldown reduction soft cap 50% & hard cap 70% in `rogue_progression_final_crit_chance` / `_final_cdr`.)
9.3 Equipment affix tags consumed by talent conditional logic (Done (initial) – weapon infusion mapped to skill tag mask via `rogue_progression_synergy_tag_mask`.)
9.4 Skill tag synergy injection (e.g., Fire tag scaling with Elementalist node) (Done (scaffold) – conditional fire bonus function `rogue_progression_synergy_fire_bonus`; future nodes can query with tag mask.)
9.5 Tests: ordering determinism, cap clamps, synergy correctness (Done – unit test `test_progression_phase9_synergy` validates layered damage math, attribute sum, crit/CDr clamping, tag bonus gating.)

PHASE 10. Buff/Debuff Integration
10.1 Extend stat engine to treat timed buffs as layer after passives (Done – stat cache now queries buff system for strength bonus layer; placeholder for other attributes.)
10.2 Snapshot vs dynamic recalculation toggle per buff (Done – per-buff `snapshot` flag stored; initial implementation preserves magnitude on later base stat changes.)
10.3 Stacking rules (unique, refresh, extend, add) (Done – implemented enum `RogueBuffStackRule` with logic in `rogue_buffs_apply`.)
10.4 Anti-oscillation dampening (avoid rapid stat flicker) (Done – global reapply interval `rogue_buffs_set_dampening`; early reapplication rejected.)
10.5 Tests: stacking semantics, snapshot freeze invariants (Done – `test_progression_phase10_buffs` validates stacking rules, buff strength layering, and dampening window.)

PHASE 11. Performance & Caching
11.1 Incremental stat recomputation dirty flags (attribute change, talent change) (Done – added dirty bit mask (attr=1,passive=2,buff=4,equipment=8) with selective layer refresh; instrumentation counters `recompute_count` & `heavy_passive_recompute_count`.)
11.2 Flattened SoA arrays for passive effects (Done – introduced SoA mirrors (stat_id[], delta[]) feeding unlock accumulation loop for cache-friendly iteration.)
11.3 Micro-bench (stat recompute under 200 talent effects) (Done – added synthetic benchmark test `test_progression_phase11_bench` measuring full vs buff-only recompute ratio.)
11.4 Cache size target (< 64 KB hot path) (Done – stat cache struct currently <2 KB; size accessor & test assert threshold.)
11.5 Tests: recompute latency P95, no stale cache after re-spec (Done – re-spec stale cache test passes; passive layer integrated into stat cache & fingerprint reflects DSL reload. P95 latency instrumentation deferred to future perf harness – scope reduced to functional correctness for Phase 11.)

PHASE 12. Persistence & Migration
12.1 Versioned progression header (level, xp, mastery, ascendancy, paragon) (Done – implemented header V1/V2 structs capturing level, total XP, attribute snapshot, spent points, respec tokens, attribute journal hash, passive journal hash, stat registry fingerprint & maze node count placeholder; read/write APIs plus chain hash & migration flags exposed; unit test exercises roundtrip & legacy V1 migration path)
12.2 Talent/ascendancy bitset or sparse list encoding (X)
12.3 Re-spec journal entries with hash chaining (X)
12.4 Migration for added stats & new talent nodes (X)
12.5 Tests: backwards compatibility, migration invariants (Partial – current test covers V1->V2 load & chain hash parity; additional tests pending for future talent / node additions)

PHASE 13. Analytics & Telemetry
13.1 Leveling velocity metrics (xp/hour by bracket) (X)
13.2 Point distribution heatmaps (talent node selection frequency) (X)
13.3 Power index (aggregate combat rating) trend lines (X)
13.4 Anomaly detection (sudden power spikes beyond expected curve) (X)
13.5 Balance dashboard export JSON (X)
13.6 Tests: anomaly false positive rate, distribution sum consistency (X)

PHASE 14. Anti-Grind & Catch-Up Mechanics
14.1 Diminishing XP returns on trivial content (gray mob scaling) (X)
14.2 Dynamic catch-up multiplier (no rested / no seasonal reset required) (X)
14.3 Soft gate for mastery spam (cooldown on identical skill XP events) (X)
14.4 Adaptive XP smoothing to mitigate streak variance (X)
14.5 Tests: multiplier boundaries, smoothing preserves mean, no negative XP scenarios (X)

PHASE 15. Security / Integrity / Exploit Mitigation
15.1 Hash-chained progression journal (level ups, point spends, re-specs) (X)
15.2 Rate limits on point re-spec & mastery gain events (X)
15.3 Deterministic stat snapshot hashing for anti-tampering (X)
15.4 Replay validator (journal -> final stats) (X)
15.5 Anomaly model (improbable mastery speed) (X)
15.6 Tests: journal tamper detection, false positive analysis (X)

PHASE 16. UI / UX
16.1 Level & XP bar with overflow indicator (X)
16.2 Attribute allocation panel (inline derived stat preview) (X)
16.3 Talent tree interactive graph (hover tooltips, path highlight) (X)
16.4 Mastery radial board + progression ring (X)
16.5 Ascendancy selection cinematic & compare panel (X)
16.6 Post-cap paragon lattice (scrollable infinite feel) (X)
16.7 Re-spec cost preview & diff summary (X)
16.8 Accessibility: text-only hierarchical list fallback (X)
16.9 Tests: state persistence (last selected tab), diff accuracy snapshot (X)

PHASE 17. Tooling & Dev Experience
17.1 CLI: dump progression snapshot & recompute verification (X)
17.2 Balance simulator (simulate 10k kill XP sessions) (X)
17.3 Talent dependency graph DOT export (X)
17.4 Automated curve tuner (optimize xp_to_next to target session length) (X)
17.5 Stress harness: random point spend / re-spec fuzz (X)
17.6 Docs auto-generation (talent markdown tables) (X)

PHASE 18. Future / Optional Extensions
18.1 Dynamic world attunements granting temporary stat shifts (Optional)
18.2 Prestige cosmetic imprint (purely visual, no stat reset) (Optional)
18.3 Mentor boost token economy (Optional)
18.4 Procedural maze mutation mini-events (Optional)
18.5 Collaborative global maze expansion unlock (Optional)

DEPENDENCIES & INTEGRATIONS
- Integrates with skills (mastery XP triggers, skill tags for effect conditions, maze unlock gating)
- Equipment stats feed baseline before passive layering
- Utilizes persistence hash chain & future anti-cheat validation modules
- Maze graph loader requires `skill_maze_config.json` & supports hot reload in dev
- Requires inventory for re-spec / maze reroute tokens (if implemented as items) else internal currency

RISKS & MITIGATIONS
- Infinite level runaway -> Sublinear growth functions + inflation telemetry (8.x,13.x)
- Maze complexity overwhelm -> Fog-of-war reveal & guided path suggestions early (UI 16)
- Path homogenization (everyone same route) -> Multiple near-equivalent path costs & rotating micro incentives (14.4,18.4)
- Stat calc latency -> Incremental dirty flags (11.1) + SoA layout (11.2)
- Exploit (XP macro / automated maze unlock) -> Rate limit + anomaly detection (15.x)
- Migration fragility -> Versioned headers + deterministic sorted node IDs (12.x)

KEY METRICS (Targets)
- Stat recompute time: < 0.4 ms P95 after maze unlock (local)
- Memory footprint (progression state excluding journal): < 28 KB (maze adds structure)
- Journal replay determinism: 100% identical hash over 100 seeds
- Level interval time variance (rolling 10-level window): CV < 0.20
- Maze path diversity: top path usage share < 40% after 2 weeks
- Sublinear scaling adherence: Effective Power growth exponent < 0.65 beyond level 200

ROLL-OUT STRATEGY
1. Phases 0–1: Taxonomy + infinite leveling core.
2. Phases 2–3: Attributes & rating curves for baseline combat scaling.
3. Phases 4–5: Maze graph ingestion + skill/passive unlock execution engine.
4. Phase 6 mastery after core maze routes proven stable.
5. Phase 7 expanded rings & keystone nodes to deepen progression.
6. Phase 8 perpetual scaling tuning once initial balance telemetry gathered.
7. Performance (11) & analytics (13) gates before large content infusion.
8. Security (15) prior to external testing; UI (16) iterative from earlier phases.

TEST PRIORITIZATION
Early: 0,1,2,3,4,5
Mid: 6,7,8,9,11,12,13
Late: 10,14,15,16,17,18

NOTES
- Infinite leveling avoids post-cap discontinuity; smoothing functions crucial to pacing.
- Maze replaces traditional class/ascendancy; all skills eventual but order matters.
- Deterministic sorted node ID list forms part of progression snapshot hash.
- Use existing fuzz infra from equipment serialization to fuzz unlock & mastery journals.
- Provide early guided path suggestions to avoid analysis paralysis for new players.
- Keep curves & maze costs data-driven (editable without recompilation) for rapid tuning.

\nCROSS-SYSTEM SYNERGIES (Added)
Ordering (High-Level) for final combat stat resolution: Base (Race/Core) -> Equipment/Base Affixes -> Progression (Attributes -> Passives/Maze Nodes -> Mastery Rings -> Perpetual Micro-Nodes) -> Temporary Buff/Debuff Layer -> Dungeon/Mutator Modifiers -> Enemy Relative ΔL & Adaptive Difficulty (applied at encounter) -> Final Clamps / Soft Caps.

Key Integrations:
1. Equipment System:
	- Attribute & passive nodes consume equipment-provided tag & stat context (e.g., weapon_tag: "fire_blade" unlocking conditional +% Fire DoT node).
	- Familiarity & durability curves influence effective skill usage DPS; mastery XP gain rate model should incorporate normalized effective_damage not raw base to avoid durability abuse (Phase 6 alignment with Equipment Phase 7+ durability). 
	- Budget caps: Progression cannot bypass equipment budget governance; passive % increases use diminishing returns curves referencing equipment soft cap metadata (Equipment Phase 2.4).
2. Loot / Item System:
	- Smart drop / upgrade guarantee (Dungeon 8.3) leverages progression power index (13.3) to detect stagnation; provide API: progression_power_index(level, passive_snapshot_hash) to loot upgrade orchestrator.
	- Reroll / salvage economy (Loot 11.x / 15.x) feeds re-spec token crafting (if tokens itemized) with drop gating via mastery tier thresholds.
3. Combat System:
	- Mastery rank bonuses limited to modifying: base damage scalar, resource cost reduction, status buildup; cannot alter frame data (Combat Phases 1A,5) to preserve predictability.
	- Reaction / i-frame windows (Combat Phase 4) unaffected by passive stacking; any dodge_related passive uses percentage additive to stamina efficiency only.
4. Skill System:
	- Maze nodes unlock new skill effect variants; effect DSL compile (Skill Phase 8.x) must treat progression node multipliers as a separate coefficient array for replay hashing.
	- Proc/buff stacking rules (Skill/Combat future phases) reference progression layer ordering to prevent snapshot abuse (snapshot vs dynamic flag recorded in unlock journal for auditing).
5. Enemy Difficulty System:
	- ΔL model (Enemy Phase 1) consumes player effective_level (could diverge from raw level if future prestige) – maintain function get_effective_level() = raw_level for now.
	- Adaptive difficulty (Enemy Phase 4) reads recent progression velocity (levels/hour) to avoid compounding difficulty spikes during rapid early leveling bursts.
6. Dungeon System:
	- Depth -> target ΔL mapping (Dungeon 10.1) uses progression curve to keep same-level challenge; provide exported table each build.
	- Puzzle gating (Dungeon 6.2) references specific maze node tags (mobility, insight) – maintain stable tag list & supply deprecation map on node rename.
7. Crafting & Gathering:
	- Mastery rank breakpoints can unlock advanced refining efficiency; progression supplies hook mastery_rank(skill_id) to crafting (Crafting Phase 5+).
	- Attribute thresholds may unlock material transmutation recipes; recipe parser reads attribute_min fields.
8. Vendor / Economy:
	- Negotiation probability (Vendor Phase 4.3) pulls Finesse/Insight effective post-passive values; expose clamped rating after DR to vendor layer.
	- Special offer weighting (Vendor Phase 6.2) can be biased by player passive specialization gaps (offer complementary stats) using progression heatmap (13.2).
9. World Boss System:
	- Boss phase unlock tokens can grant maze expansion triggers (Phase 7 ring layers); progression listens for boss_kill events with phase_id.
	- Mastery XP multipliers granted post-boss kill for underutilized skills to encourage diversity.
10. Analytics / Telemetry Synergy:
	- Unified Power Index = f(equipment_budget_utilization, progression_attribute_vector, mastery_distribution_entropy, passive_keystone_count, effective_level).
	- Drift detection across systems shares a consolidated StatsSnapshot (hash + component hashes: equip, progression, skill loadout) for multi-dimensional anomaly models.

Testing & Integrity Cross-Checks:
 - Golden Master: progression_snapshot_hash + equipment_stat_fingerprint must be deterministic across reload; CI test combines both and replays maze unlock sequence vs equip changes.
 - Journal Replay: Apply equipment changes then progression unlocks vs reversed order -> identical final stat cache (commutativity guard except for intentional ordering of diminishing returns).
 - Anti-Exploit: Re-spec rate limiter checks vendor transaction journal for token purchases to detect external economic acceleration.

Open Dependency Actions (Not Yet Implemented):
 - Provide public C API: progression_export_power_index(), progression_get_attribute_effective(), progression_get_mastery_rank(skill_id), progression_snapshot_serialize(buffer).
 - Maintain tag registry file mapping skill/equipment/dungeon puzzle tags -> progression node predicates.
 - Add per-node optional field: external_dependency_ids[] to quickly audit breakage when other systems rename identifiers.

Change Impact: This section is documentation only; no code changes required but upcoming tasks should create the referenced APIs and audit tests linking multi-system ordering.


