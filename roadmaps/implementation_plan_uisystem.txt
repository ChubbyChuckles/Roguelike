UI / UX SYSTEM IMPLEMENTATION PLAN (Roadmap & Status)

Legend:
Done = Fully implemented & tests pass (or empirically verified in runtime)
Partial = Some components implemented (details in parentheses)
X = Not started yet

Scope Overview:
A modular, data‑driven UI / UX layer decoupled from simulation. Goals: deterministic headless testing, scalable theming, accessibility (a11y), input abstraction (keyboard / mouse / controller), lightweight retained + immediate hybrid rendering, virtualization for large inventories / logs, animation & transition framework with time dilation safety, and clear extensibility for modding. All UI state is serializable for replay and snapshot debugging.

PHASE 0. Current Baseline (Partial)
0.1 Ad‑hoc HUD overlays (health, XP, damage numbers) (Partial: basic HUD)
0.2 Vendor & equipment panels (Partial: minimal vendor panel & equipment display)
0.3 Skill tree popup (Partial: rank allocation logic present)
0.4 Start screen simple menu (Done)

PHASE 1. Core Architecture & Module Boundaries
1.1 Establish ui/ module with subfolders: core/, widgets/, layout/, themes/, test/ (Done)
1.2 Unified UIContext (tree root, focus stack, theme, timing) (Done: basic context + theme + rng)
1.3 Frame lifecycle API: ui_begin(), ui_update(dt), ui_render(), ui_end() (Done: begin/end; render stub to be added later)
1.4 Deterministic UI RNG channel (for cosmetic jitter) (Done: dedicated xorshift32 state + tests)
1.5 Separation: simulation <-> UI via read‑only snapshot structs (Done: snapshot pointer + size, read-only accessor)
1.6 UI state diff / snapshot serialization (Done: deterministic text serializer + FNV-1a hash diff API + test)
1.7 Memory arenas / pools for UI transient allocations (Done: per-frame arena with reset on begin, text_dup convenience)

PHASE 2. Widget Primitives & Composition
2.1 Core primitives: Panel, Text, Image, Sprite, ProgressBar (Done: nodes + unit test)
2.2 Interactive: Button, Toggle, Slider, TextInput (buffer + cursor) (Done: basic hit testing, toggle, slider drag, text input focus + char/backspace handling, tests)
2.3 Container + layout nodes: Row, Column, Grid, LayerStack (Done: row/column incremental layout APIs, grid cell helper, layer node; unit test added)
2.4 Scroll container with inertial scrolling & virtualization hooks (Done: basic vertical scroll offset + wheel delta API; inertial easing & virtualization hooks to extend later)
2.5 Tooltip system (hover intent timing, anchored) (Done: delayed hover -> panel + text spawn)
2.6 Declarative widget DSL (C macro or data schema) (Done: initial C convenience macros for Panel/Text/Button)
2.7 Widget ID hashing & stable path addressing (Done: FNV1a hash from label, runtime lookup API, stable across frames test)
2.8 Focus & navigation graph (Done: directional heuristics selecting nearest neighbor with axis bias + activation; wraps fallback)

PHASE 3. Input Abstraction & Interaction Model
3.1 Input routing priority (Done: modal gating enforced in widgets + focus override; chord + paste + text routed via focus; recording respects routing)
3.2 Controller mapping: analog navigation & action binding layer (Done: axis -> directional intent with threshold + repeat integration)
3.3 Text input IME support stub & clipboard integration (Done: clipboard setter/getter + IME start/cancel/commit stubs + paste into text input)
3.4 Key repeat timing & acceleration curve (Done: initial delay + interval synthetic directional/tab/activate + axis repeat leveraging same machinery)
3.5 Chorded shortcut / command palette infrastructure (Done: chord register, two-step detection with timeout, last command query)
3.6 Automated input replay for UI tests (Done: recording/playback buffer + per-frame injection step API + records new inputs)

PHASE 4. Inventory / Equipment / Vendor Interfaces
4.1 Inventory grid widget with slot virtualization (partial redraw) (Done: minimal static grid nodes + deterministic serialization; virtualization & scrolling incremental)
4.2 Drag & drop (payload struct, ghost rendering, snapback) (Done: basic drag state, swap, events; ghost rendering/snapback animation TBD)
4.3 Stack split UI (modal numeric adjust) (Done: CTRL+click open, wheel adjust, apply/cancel events)
4.4 Context menus (equip, salvage, compare) (Done: basic right-click open, keyboard navigate, select/cancel events)
4.5 Inline stat delta preview (green/red diff) (Done: basic damage delta panel on hover with events STAT_PREVIEW_SHOW/HIDE; future: full equipment comparison, multiple stats)
4.6 Price / rarity color theming integrated (Done: inventory grid now renders rarity-colored borders & count text via deterministic mapping; future: hook actual item defs & price display overlay)
4.7 Vendor restock timer bar & progress (Done: restock progress bar + ETA label in vendor panel; helper API exposes fraction; unit test validates fraction computation)
4.8 Transaction confirmation & insufficient funds UX (Done: confirmation modal with item name & price, ENTER opens/accepts, ESC cancels, insufficient funds flash overlay ~0.5s; headless test `test_ui_phase4_vendor_transaction` simulates open->insufficient->fund->purchase)
4.9 Equipment durability & repair UI with thresholds (Done: equipment panel shows color-coded durability bar (green>=60%, amber>=30%, red<30%) plus warning '!' icon at critical; text color matches state; helper `rogue_durability_bucket` unit-tested in `test_ui_phase4_durability_thresholds`)
4.10 Controller friendly radial selector (Done: radial menu open/choose/cancel events, analog stick angle -> wedge selection, keyboard arrow cycling fallback, test `test_ui_phase4_radial_selector` validates open + axis mapping + choose event)

PHASE 5. Skill Tree / Progression UI
5.1 Zoomable panning skill graph (quad‑tree culling) (Done: basic world->screen transform, quadtree build, culling, emission API + unit test `test_ui_phase5_skillgraph`)
5.2 Node layering: base icon, rank pips, synergy glow (Done: layered emission now includes background panel, synergy glow underlay color 0x30307040u, rank ring, icon sprite placeholder sheet=0, per-rank pip bars with fill overlay, rank text; updated unit test)
5.3 Rank allocation animations (pulse, currency spend flyout) (Done: pulse (280ms scale+fade) & spend flyout (600ms upward fade) implemented with arrays skillgraph_pulses[32]/skillgraph_spends[32]; lifecycle advanced in rogue_ui_begin; unit test `test_ui_phase5_skillgraph_anim` validates creation & expiry)
5.4 Passive synergy aggregate panel (X)
5.5 Search / filter by tag (fire, movement, defense) (X)
5.6 Build export/import serialization (X)
5.7 Undo buffer (last N allocations) (X)

PHASE 6. HUD Modularization & Overlays
6.1 HUD layout spec file (JSON/TOML) for placing bars/panels (X)
6.2 Health / Mana / AP bars: layered gradients + status overlays (X)
6.3 Buff & debuff icon belt with stack counters / timers (X)
6.4 Floating combat text batching + occlusion / fade curves (Partial: damage numbers basic)
6.5 Minimap interactive overlay toggles (Partial: minimap exists)
6.6 Alert system (level up, low health, vendor restock) (X)
6.7 Performance metrics overlay with toggle (Partial: metrics module exists)

PHASE 7. Theming & Accessibility
7.1 Theme asset pack (colors, font sizes, padding metrics) (X)
7.2 Dynamic theme hot‑swap & diff (X)
7.3 High contrast / colorblind palettes (protanopia/deuteranopia/tritanopia) (X)
7.4 Scalable UI (DPI scaling & user preference) (X)
7.5 Reduced motion mode (disables large transitions) (X)
7.6 Screen reader / narration stubs (future extensibility) (X)
7.7 Focus highlight & tab order auditing tool (X)

PHASE 8. Animation & Transitions
8.1 Easing library (cubic, elastic, spring) (X)
8.2 Timeline / keyframe system with interrupt policies (X)
8.3 Entrance/exit transitions (mount/unmount) (X)
8.4 Physics spring micro‑interactions (button press) (X)
8.5 Global time dilation integration (hitstop aware UI timers) (X)

PHASE 9. Performance & Virtualization
9.1 CPU budget instrumentation per phase (update/render) (X)
9.2 Dirty rectangle culling & partial redraw (X)
9.3 Text shaping cache & glyph atlas compaction (X)
9.4 Large list virtualization (inventory, logs) (X)
9.5 Frame time regression guardrails (baseline snapshot) (X)

PHASE 10. Testing & QA Automation
10.1 Headless UI harness (software raster target or hash) (X)
10.2 Golden image diff tests (tolerance thresholds) (X)
10.3 Automated navigation traversal test (focus cycles) (X)
10.4 Property fuzz tests (layout never overlaps reserved system bars) (X)
10.5 Performance smoke test (scripted 5k widgets) (X)
10.6 Theming diff test (light vs dark invariants) (X)

PHASE 11. Documentation & Tooling
11.1 UI component style guide (generated catalog) (X)
11.2 Developer overlay: hierarchy inspector & live property edit (X)
11.3 Crash snapshot: serialize UI tree & inputs (X)
11.4 Contribution checklist (API stability, a11y compliance) (X)

DEPENDENCIES / RISKS
- Need deterministic text rendering hash to enable golden tests.
- Memory fragmentation risk if transient allocations not pooled.
- Controller abstraction early prevents rewrite later.

SUCCESS METRICS
- <2ms average UI update+render under standard load (1080p) by Phase 9.
- Zero focus traps (automated traversal complete) by Phase 10.
- 95% widget lines covered by automated tests.

NEXT ACTION CANDIDATES (If starting now)
- Implement Phase 1.1–1.3 scaffolding.
- Add headless test harness stub & a single Panel+Text widget demo.
