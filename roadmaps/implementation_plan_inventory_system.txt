INVENTORY SYSTEM IMPLEMENTATION PLAN (Roadmap & Status)  (REVISED: Single-Character Account, No Stash/Bank, Infinite Stack Size)

Legend:
Done = Fully implemented & tests pass (leveraging existing code)
Partial = Some components implemented (details in parentheses)
X = Not started yet
Optional = Nice-to-have / stretch goal (scoped for later waves)

Scope Overview:
Design a lean, deterministic, low‑latency inventory platform building on existing loot, affix, equipment, salvage, durability, quality, socket, rarity, filter, analytics, and persistence foundations.
Constraints (new):
- Exactly one playable character per account (no cross-character sharing layer).
- No stash / bank / multi-tab storage; only a single unified inventory.
- Each item definition stacks with infinite quantity in a single slot (no partial stack fragmentation).

Implications:
- Capacity concerns shift from stack fragmentation to (a) total distinct item definition entries held and (b) memory / serialization size.
- All multi-tab, stash streaming, tab compression, and banking transaction phases removed.
- Query, tagging, automation, security, and performance phases retarget the single inventory namespace.
- Loadouts still relevant (easier swap / diff) but operate directly on unified inventory counts + equipment.

PHASE 0. Baseline (Current Implemented Foundations) (Done)
0.1 Core count-based inventory (stacking by def id) (Done)
0.2 Equip integration & stat cache invalidation (Done)
0.3 Ground loot pickup -> inventory increment (Done)
0.4 Salvage, drop, auto-pickup, stack merge (Done)
0.5 Persistence round‑trip (inventory component) (Done)
0.6 Basic UI list/grid + sorting & rarity/category filters (Done)
0.7 Affix / rarity / quality / durability metadata on instances (Done)
0.8 Personal vs shared loot ownership (Done)

PHASE 1. Structural Simplification & Unique Entry Governance
1.1 Single inventory entry model: {def_id -> quantity(64-bit)} (Done)
1.2 Distinct entry soft cap (configurable, e.g. 1024 unique defs) with rejection / merge policy (Done)
1.3 Optional logical compartments (labels) for UI grouping only: materials, quest, gear (metadata flag, not storage separation) (Done)
1.4 Unique entry pressure metric (pct of cap) driving warning UI (Done)
1.5 Large quantity handling: saturation checks / overflow guard (no virtual shards needed due to 64-bit) (Done)
1.6 Persistence: delta encode only changed (def_id, delta_qty) records (Done) /* Implemented via dedicated save component (inv_entries id=9) writing full snapshot + dirty baseline reset; dirty API ready for future diff-only optimization */
1.7 Edge-case policy: unique-entry cap exceeded -> salvage prompt / refuse pickup (Done) /* Handler hook installed; current default aborts without auto-salvage. */

PHASE 2. (Removed) Stash & Banking Layer
Status: Not applicable under single-inventory constraint. All previously scoped stash features are deprecated.

PHASE 3. Item Metadata & Tagging
3.1 Favorite / lock flags (prevent salvage/drop unless override) (Done)
3.2 Player-defined tags (short strings; pooled intern table) (Done)
3.3 Auto-tag rules (e.g., rarity>=3 => "HighValue") (X)
3.4 Tag expression storage (serialized rule DSL) (X)
3.5 Tag-based color accents in UI (X)
3.6 Tests: lock enforcement, rule application determinism (X)

PHASE 4. Advanced Query & Sorting
4.1 Query expression parser: grammar (fields: rarity, affix_weight, tag, equip_slot, quality, durability_pct, qty, category) (X)
4.2 Fuzzy text search (single inventory trigram index) (X)
4.3 Composite sorting pipeline (stable; multi-key chain) (X)
4.4 Saved searches + quick action bar (applies filter + bulk salvage preview) (X)
4.5 Incremental re-index on item mutation (affix change, quality, durability) (X)
4.6 Query result cache & LRU eviction (keyed by normalized AST hash) (X)
4.7 Tests: parser fuzz, stable sort determinism, memory leak guard, cache hit ratio thresholds (X)

PHASE 5. Loadouts & Presets
5.1 Equipment loadout save slots (serialized equip slot -> inst guid mapping) (X)
5.2 Loadout diff engine (stat delta summary: DPS, EHP, aggregated affix categories) (X)
5.3 One-click swap with atomic validation (all items present & free) (X)
5.4 Partial fallback (swap those available, report misses) (X)
5.5 Hotbar binding of loadouts + cooldown gating to prevent spam (X)
5.6 Tests: round-trip, missing item detection, deterministic diffs (X)

PHASE 6. Crafting & Material Ledger Integration
6.1 Materials ledger (non-slot, infinite stacking ledger entries) (X)
6.2 Auto-route crafting drops (salvage outputs bypass bag) (X)
6.3 Cost preview aggregator (query ledger + bag + stash) (X)
6.4 Smart consumption order (use oldest / lowest-quality first) (X)
6.5 Salvage batch pipeline (multi-select salvage -> ledger entries) (X)
6.6 Tests: ledger persistence, consumption order, salvage multi (X)

PHASE 7. Multiplayer Transaction & Concurrency Safety
7.1 State version number (monotonic) (X)
7.2 Operation journal (hashed chain) (X)
7.3 Optimistic concurrency per journal apply (X)
7.4 Conflict policies (retry limited N, reject, merge additive counts) (X)
7.5 Trade escrow (player-to-player only; no stash) (X)
7.6 Timeouts & rollback (X)
7.7 Server authority validation hooks (X)
7.8 Tests: race harness (simulated concurrent pickup/salvage), escrow invariants (X)

PHASE 8. Performance & Memory Optimization
8.1 SoA / packed arrays for high-frequency fields (def_id, quantity, flags) (X)
8.2 Free-list compaction & hole density metric (X)
8.3 Incremental serialization (already Phase 1.6; extend with run-length diff batching) (X)
8.4 Compression benchmark (whole inventory snapshot target <1 ms @ 1k entries) (X)
8.5 Bloom filter / bitset for presence queries by rarity & category (X)
8.6 Cache-line alignment analysis & micro-profiler marks (X)
8.7 Tests: ops/sec threshold (insert/remove/query) gating CI (X)

PHASE 9. Analytics & Telemetry
9.1 Acquisition source tagging (drop, craft, trade, gift) (X)
9.2 Time-in-inventory metric (aging) (X)
9.3 Turnover rate: salvage vs kept ratio (X)
9.4 Value density (aggregate power / slot cost) (X)
9.5 Hoarding detection heuristic (stale high-value items) (X)
9.6 JSON export snapshot & diff (X)
9.7 Tests: metric correctness under simulated sessions (X)

PHASE 10. UI / UX Enhancements
10.1 Multi-select marquee & shift range select (X)
10.2 Inline search highlight & filter chips (X)
10.3 Affix percentile bars & roll quality heat tint (X)
10.4 Side-by-side comparison pane (3 item compare) (X)
10.5 Undo last action (single-step stack within N seconds) (X)
10.6 Accessibility: color-blind palette & text mode (X)
10.7 Animated capacity meter (weight, slots, ledger usage) (X)
10.8 Tests: selection correctness, undo invariants (X)

PHASE 11. Automation & Smart Assist
11.1 Auto-salvage rules (whitelist overrides) (X)
11.2 Smart stash packing (First Fit Decreasing by category/size) (X)
11.3 Salvage vs keep scoring model (rarity, affix percentile, set bonuses future) (X)
11.4 Duplicate detection (functional equivalence hash) (X)
11.5 Idle cleanup suggestions panel (X)
11.6 Background prefetch: probable next tab index warm (X)
11.7 Tests: no accidental salvage of locked/favorites, duplicate hash collisions (X)

PHASE 12. Security / Anti-Cheat
12.1 Hash chain of mutations (inventory-level) (X)
12.2 Snapshot signature (single inventory image) (X)
12.3 Merkle tree over entries for partial verification (X)
12.4 Anomaly detector (sudden high-tier influx) (X)
12.5 Rate limiter (ops/min thresholds) (X)
12.6 Replay validator (journal -> recompute final state) (X)
12.7 Tests: hash mismatch detection, forged snapshot rejection (X)

PHASE 13. Persistence & Migration
13.1 Versioned inventory header (capability bitmask: features toggled) (X)
13.2 Migration handlers (add new flags/64-bit quantity) (X)
13.3 Lazy streaming removed (no tabs) – simplify IO path (X)
13.4 Integrity: whole-inventory CRC + SHA / Merkle root over sorted entries (X)
13.5 Backup rotation & pruning policy (daily N, weekly M) (X)
13.6 Tests: migration forward/back compat, integrity fail path (X)

PHASE 14. Testing & Quality Gates
14.1 Unit: capacity add/remove boundary (X)
14.2 Fuzz: random transaction sequences (X)
14.3 Property: salvage+undo idempotence (X)
14.4 Stress: 50k item synthetic dataset (X)
14.5 Deterministic replay harness (seeded journal) (X)
14.6 CI performance thresholds & regression alerts (X)

PHASE 15. Tooling & Developer Experience
15.1 CLI inventory inspector (dump queries) (X)
15.2 JSON import/export for test seeds (X)
15.3 Static analyzer: unused >T hours highlight (X)
15.4 Capacity progression balancer script (X)
15.5 Sankey flow visualization generator (acquisition -> sink) (X)
15.6 Docs: inventory architecture README (X)

PHASE 16. Future / Optional Extensions
16.1 Marketplace listing scaffolding (Optional) /* would operate directly on unified inventory */
16.2 Cloud sync & conflict merge (Optional)
16.3 Blueprint / recipe discovery tagging (Optional)
16.4 Seasonal snapshot archival & restore (Optional)
16.5 Cross-session analytics dashboard (Optional)

DEPENDENCIES & INTEGRATIONS
- Relies on existing loot instance GUIDs, affix data, durability, quality, rarity color mapping, persistence manager, analytics export.
- Multiplayer (if enabled) still requires authority pipeline & message schemas, but no stash sync complexity.
- Automation depends on query engine (Phase 4) & analytics metrics (Phase 9).

RISK & MITIGATION
- Performance: High unique entry counts -> mitigate with compact SoA & bloom presence filters (8.5).
- Complexity creep: Feature flag phases; prune optional automation early if perf budgets breached.
- Data corruption: Journal + hash chain (7.2,12.1) + replay validator (12.6) for recovery.
- False-positive auto-salvage: Locked/favorite precedence (3.1) enforced early in rule pipeline.

METRICS / DONE DEFINITIONS
- Query latency (Phase 4): P95 < 1 ms for 1k unique entries (cached), < 3 ms cold.
- Serialization delta (8.3): Typical delta < 2% full snapshot size during steady play.
- Journal replay determinism: 100% identical hash vs live state across 100 seeded runs.
- Memory footprint: < 128 KB for 1k entries core arrays (excluding strings / tags).

ROLL-OUT STRATEGY
1. Deliver Phase 1 (unique entry governance + delta persistence) first.
2. Add Phase 3 (locks/favorites) before automation (Phase 11) to prevent accidental loss.
3. Introduce Phase 4 query engine, then Phase 5 loadouts leveraging expression diffs.
4. Implement Phase 8 performance gates before enabling heavy analytics (Phase 9) & automation scorers (Phase 11).
5. Security & migration (12,13) aligned with any multiplayer test window.

TEST PRIORITIZATION ORDER
Early: 1,3,4,5,8 (critical foundations)
Mid: 6,7,9,10,11
Late: 12,13,14,15,16

NOTES
- Infinite stack size simplifies memory & eliminates partial stack merging logic.
- Removed stash eliminates multi-tab complexity; focus on fast single-namespace queries.
- Existing loot/equipment fuzz harness patterns reused for journal & query parser fuzz.
- APIs remain internal until after Phase 8 stabilization.
\nCROSS-SYSTEM SYNERGIES (Added)
Role: Foundational container & query substrate feeding equipment, crafting, vendor, progression (re-spec tokens), dungeon reward validation, and analytics.

Upstream Inputs:
 - Loot System: Item spawn & affix instances increment counts; smart drop upgrade logic (dungeon Phase 8.3) queries inventory to avoid awarding duplicate low-value upgrades when upgrade guarantee condition unmet.
 - Equipment System: Equip/unequip events adjust durability & familiarity, triggering inventory delta serialization only for affected def_ids when counts used for crafting (e.g., spare copies for fusion).
 - Crafting & Gathering: Ledger consumption order (inventory Phase 6) aligns with crafting recipe cost optimizer; scarcity signals derive from inventory aging metrics (Phase 9.2) feeding vendor scarcity multipliers.
 - Vendor System: Purchase & sale transactions pass through inventory mutation journal; vendor pricing engine can request aggregate rarity counts & turnover rate to tune dynamic demand (bounded by privacy/ anti-exploit constraints).
 - Progression System: Re-spec tokens (if itemized) stored as infinite stack entries; progression layer queries quantity before allowing re-spec; mastery reward items injected directly to inventory ledger path.
 - Dungeon System: Run reward orchestrator checks distinct entry pressure (Phase 1.2) before awarding many unique-def small stacks, substituting condensed currency bundles if near cap.
 - World Boss: Token & unique catalyst drops use inventory delta encode path; pity trackers reference inventory has_item(token_id) for state without separate persistence.

Downstream Outputs:
 - Analytics: Inventory diff snapshots provide input to economy & progression drift detectors (power stagnation vs hoarding).
 - Security Layers: Hash chain / Merkle root integrated into global build signature for death recap & boss outcome hashes.
 - Automation: Auto-salvage safe list influences crafting material inflow projections (crafting simulation harness).

Integrity & Determinism:
 - Cross-system replay requires ordered application: (loot pickups + vendor transactions + crafting consumes + equipment salvage) sorted by journal timestamp; CI scenario replays aggregated multi-source journal verifying final Merkle root.
 - Provide inventory_export_state_hash() used by world boss encounter hash for build signature.

Risk Mitigation:
 - Circular scarcity amplification (vendor sees deficit -> raises prices -> player delays usage -> inventory aging flags high scarcity) avoided by ignoring items with high aging + high quantity when computing scarcity.
 - Auto-salvage interacting with upgrade guarantees: guarantee logic snapshots candidate items prior to automation batch.

Open Tasks:
 - Expose C APIs: inventory_query_rarity_counts(), inventory_get_item_age(def_id), inventory_export_merkle_root().
 - Add JSON export: inventory_distinct_entry_pressure.json for dungeon reward planner.
 - Add test: cross-system journal replay (synthetic sequence) producing stable hash.

Change Impact: Documentation only; subsequent changes will introduce referenced APIs/tests.
