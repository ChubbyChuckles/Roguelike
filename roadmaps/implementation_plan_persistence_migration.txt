PERSISTENCE & MIGRATION ROADMAP (Save Versioning / Integrity / Replay)

Legend:
Done = Fully implemented & tests pass (or empirically verified)
Partial = Some components implemented (details in parentheses)
X = Not started yet

Scope Overview:
Robust, versioned persistence layer covering player progression, world generation seeds, inventory / loot instances, skill & buff states, vendor inventory, and meta analytics. Goals: schema evolution without breaking old saves, deterministic replay, corruption resilience, atomic writes, integrity hashing, selective subsystem snapshots, streaming & incremental autosave, migration registry, compression, and future multiplayer authoritative compatibility.

PHASE 0. Current Baseline (Partial)
0.1 Basic player stats load/save (Partial: flat key=value file)
0.2 Ad‑hoc generation seed storage (Partial)
0.3 No explicit versioned schema / migrations (X)
0.4 No integrity verification or atomic swap (X)

PHASE 1. Core Save Architecture
1.1 Central SaveManager module (save/ directory) (Done)
1.2 Save descriptor struct (version, timestamp, checksum, component mask) (Done)
1.3 Canonical save path strategy (profile slots + autosave ring) (Done)
1.4 Atomic write (temp file + rename) (Done; durability toggle added, fsync/_commit optional)
1.5 Deterministic ordering of serialized sections (qsort by id) (Done)
1.6 Component registries: player, inventory, skills, buffs, vendor, world_meta (Done)

PHASE 2. Versioning & Migration Infrastructure
2.1 Global SAVE_FORMAT_VERSION constant (Done; bumped to v2)
2.2 Migration registry array (from_version -> fn) (Done: registration + linear migration walking, no-op chain supported)
2.3 Incremental migration runner w/ rollback if failure (Done)
2.4 Migration logging & metrics (duration, steps) (Done)
2.5 Test harness: fabricate legacy versions & auto-upgrade (Done: chain + metrics tests)

PHASE 3. Serialization Format & Schema
3.1 Sectioned binary format (header + TLV per component) (Done: v3 TLV headers uint16 id + uint32 size, tests: test_save_v3_tlv_headers, backward compat test_save_v2_backward_load)
3.2 Human-readable debug export (JSON/TOML) toggle (Done: runtime toggle via rogue_save_set_debug_json producing save_slot_X.json; tests: test_save_debug_json_toggle)
3.3 Fixed endianness & numeric width assertions (Done: compile-time static_assert on uint16/32/64 sizes + runtime little-endian helper; optional ROGUE_STRICT_ENDIAN gate present)
3.4 Compact varint encoding for counts/ids (Done: v4 introduces unsigned LEB128 for inventory item count, skill count, buff count; item/skill/buff ids remain unchanged where 32-bit needed; migration v3->v4 registered no-op since reader branches by version)
3.5 String interning table for repeated keys (Done: added component id 7 with varint-coded count + (len,varint)+bytes entries, API rogue_save_intern_string / get / count, included automatically in saves v5, migration v4->v5 no-op)
3.6 Optional compression (Done: simple RLE per-section when enabled; high bit of size marks compressed, uncompressed size prefix; API rogue_save_set_compression(enabled,min_bytes); migration v5->v6 no-op)

PHASE 4. Integrity & Security
4.1 CRC32 per section + overall SHA256 (Done: v7 adds per-section CRC32 appended after each section payload (uncompressed) and overall SHA256 footer magic SH32+digest; APIs rogue_save_last_sha256/hex; test_save_v7_integrity validates roundtrip & enumeration)
4.2 Replay hash of gameplay-critical inputs separated from UI state (X)
4.3 Tamper detection flags (version mismatch / hash fail) (X)
4.4 Recovery attempt (restore previous autosave) (X)
4.5 Optional signature abstraction (future) (X)

PHASE 5. Incremental & Streaming Saves
5.1 Dirty flag tracking per component (bitmask) (X)
5.2 Incremental write of only dirty sections (X)
5.3 Background compression thread (non-blocking) (X)
5.4 Save time budget enforcement (slice over frames) (X)
5.5 Streaming world chunk meta (future expansion) (X)

PHASE 6. Autosave & Scheduling
6.1 Autosave interval & conditions (combat idle / out of danger) (X)
6.2 Ring buffer (N autosave slots with timestamp) (Done: basic ring save paths; timestamp future enhancement)
6.3 On-demand quick save (manual trigger) (X)
6.4 Failure telemetry (write time, size) (X)
6.5 UI indicator + throttling (X)

PHASE 7. Data Domains & Component Details
7.1 Player stats & progression (level, xp, allocation) (Partial)
7.2 Skill ranks, cooldown states, casting progress (X)
7.3 Buff/debuff active list w/ remaining durations (X)
7.4 Inventory instances, equipment slots, durability (Partial: durability logic runtime)
7.5 Vendor inventory (seed, stock TTL) (X)
7.6 World seeds & biome modifiers (Partial)
7.7 Analytics counters (damage dealt, gold earned) (X)
7.8 Run metadata (permadeath flag, start timestamp) (X)

PHASE 8. Migrations — Concrete Examples
8.1 v1 -> v2: split CRIT stats into chance & damage (X)
8.2 v2 -> v3: introduce skill synergy buckets (X)
8.3 v3 -> v4: add durability extra field for armor (X)
8.4 v4 -> v5: compress inventory section (X)
8.5 v5 -> v6: restructure buffs into typed effect records (X)

PHASE 9. Deterministic Replay Support
9.1 Input event stream capture (compressed) (X)
9.2 Snapshot + delta frames (keyframe every N frames) (X)
9.3 Replay validator (resimulate & hash compare) (X)
9.4 Divergence diagnostics (first mismatching entity state diff) (X)

PHASE 10. Testing & QA
10.1 Unit tests: encode/decode roundtrip for each section (Partial: global roundtrip + autosave + ordering + migration metrics; per-section decode tests pending)
10.2 Fuzz tests: random truncated / corrupted bytes (X)
10.3 Migration matrix test (all historical versions upgrade) (X)
10.4 Performance test: incremental vs full save timing (X)
10.5 Load under failure (simulate disk full) (X)
10.6 Determinism test: save+reload does not alter live hash (X)

PHASE 11. Tooling & Debugging
11.1 save_inspect CLI (list sections, print JSON, diff) (X)
11.2 save_repair CLI (attempt salvage) (X)
11.3 In-game debug overlay: last save time & size (X)
11.4 Hex + structured viewer for developer convenience (X)
11.5 Migration report generator (markdown changelog) (X)

PHASE 12. Documentation
12.1 Persistence architecture overview doc (X)
12.2 Migration authoring guidelines (idempotency, ordering) (X)
12.3 Corruption response playbook (X)
12.4 Format spec (wire layout, endianness) (X)

PHASE 13. Performance & Footprint
13.1 Target size budgets per section (track stats) (X)
13.2 Compression ratio monitoring & thresholds (X)
13.3 Save latency P95 < 10ms (main thread) (X)
13.4 Memory overhead for save buffers < 2% total (X)

DEPENDENCIES / RISKS
- Need stable entity id mapping to store references.
- Compression thread must avoid race with read-after-write.
- Migration order mistakes can corrupt saves; strict tests required.

SUCCESS METRICS
- 100% historical version upgrade pass rate in CI.
- No data loss in simulated corruption repair for >=70% truncated cases (except intentionally unrecoverable sections).
- Full save under target size (<S TBD, e.g. 256KB) for average run mid-game.
- Deterministic replay hash stable across save/load boundaries.

NEXT ACTION CANDIDATES
- Add Phase 2 migration registry + baseline version constant.
- Implement autosave ring + fsync durability option.
- Unit tests: roundtrip (all components), deterministic order, checksum verify, partial component absence.
