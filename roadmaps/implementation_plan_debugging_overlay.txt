DEBUG OVERLAY SYSTEM IMPLEMENTATION PLAN (Roadmap & Status)

Legend:
Done = Fully implemented & tests pass
Partial = Some components implemented (details in parentheses)
X = Not started yet
Optional = Stretch / future wave

Scope Overview:
Design and implement a unified in-game debug overlay system that enables real-time inspection, live parameter editing, feature testing, and dynamic content authoring without restarts. Migrate asset data (skills, items, tilesets, entities, etc.) to external JSON with robust validation and round-trip save/load. Expose all debugging logic as modular C APIs that are usable by unit tests (headless) and by the overlay (interactive), promoting separation of concerns and testability. Keep runtime overhead near-zero when overlay is disabled; be efficient when enabled. Maintain SDL2 for rendering/input, cJSON for JSON. Implement the overlay UI in pure C with an immediate-mode API similar to ImGui.

Non-Goals (for v1):
- Full-blown editor for every system (aim for targeted inspectors/editors first).
- Undo/redo and multiplayer sync (list as extensions).

FOUNDATIONAL ASSUMPTIONS / CURRENT STATE
- SDL2 rendering/input (Done)
- Basic text rendering capability (SDL_ttf or bitmap fonts) (Assumed)
- cJSON library available or vendorable (Partial)
- Build system supports conditional compilation (CMake) (Done)

CI VALIDATION (current)
- Overlay core/input/widgets/panels compile clean under Debug with SDL2.
- Full test suite re-run in Debug (SDL2) with parallelism (-j12): all tests passed (100%) (568/568).
- Player Debug Panel and headless-safe player_debug APIs integrated; god mode is honored in melee mitigation path; noclip flag plumbed in app state. Rebuild and full test run reconfirmed green.
- Start Screen corrupt-header gating verified via unit test and in the full run; logging defaults to WARN to keep CI output quiet.
- Audio/VFX refactor: legacy monolith (effects.c) fully split into modular fx_bus.c, fx_audio.c, fx_vfx.c, fx_rng.c and the monolithic file removed; public API in effects.h unchanged.
- Entities Inspector and headless-safe entity_debug APIs compile and are covered by a new unit test; overlay wiring verified by build, and test validates spawn/list/get/teleport/kill operations.
 - Entities content schema validator added (`schema_entities.{h,c}`) with a headless unit (`test_entity_schema`) validating enemy type definitions from assets; green in full suite.
 - Tilesets content schema validator added (`schema_tilesets.{h,c}`) with a headless unit (`test_tilesets_schema`) that parses legacy `assets/tiles.cfg` to JSON and validates fields (id, tile_size, atlas, tiles[name/col/row]); integrated into build and green in full suite.
 - Map debug JSON loader fixes landed (literal detection and pointer advance) and a new unit `test_map_debug` validates edit operations and JSON round‑trip.
 - Persistence tests stabilized under parallel runs via centralized save path builders and per‑test isolation (env ROGUE_TEST_SAVE_DIR or per‑PID dir). All persistence/integrity units updated; full suite green.

PHASE 1. Project Setup & Build Integration
1.1 Add build flags: ROGUE_ENABLE_DEBUG_OVERLAY, ROGUE_ENABLE_JSON_CONTENT (Done – both flags added and propagated via CMake)
1.2 Create project structure: src/debug_overlay/, src/content/, src/tools/ (Partial – src/debug_overlay/ in place)
1.3 Add CMake targets: rogue_debug_overlay, rogue_content_json libraries (Done – object libraries compiled and linked into rogue_core conditionally)
1.4 Vendor cJSON under third_party/cjson/ with CMake target if needed (Done – vendored minimal stub cJSON and linked as rogue_thirdparty_cjson when JSON content is enabled)
1.5 Tests: basic build with/without debug overlay flags (Partial – unit test added to verify flag behavior; dual-config CI still TBD)

PHASE 2. JSON I/O Foundation
2.1 Implement json_io.h/.c: common JSON read/write, error handling, atomic save (Done – read_file, write_atomic, get_mtime_ms with char* err, int cap)
2.2 Design versioned JSON schema envelope: $schema, version, entries (Done – json_envelope.{h,c} create/parse; entries captured verbatim JSON)
2.3 Add error buffer conventions: all functions accept char* err, int cap (Done – applied to json_io and json_envelope)
2.4 Implement file utilities: temp paths, atomic rename, mtime tracking (Done – write_atomic uses sidecar temp + MoveFileExW/rename; mtime via Win32/POSIX)
2.5 Tests: JSON load/save roundtrip, error handling, atomic save safety (Done – test_json_io); envelope parse/create and errors (Done – test_json_envelope)

PHASE 3. Items JSON Schema & Migration
3.1 Design items.json schema: id, name, type, stats, rarity, tags (X)
3.2 Implement schema_items.h/.c: load/parse/validate/save functions (X)
3.3 Add item registry with stable handles/IDs for runtime lookups (X)
3.4 Create migration tool to export existing items to JSON format (X)
3.5 Tests: item load/validate/save/reload roundtrip, invalid cases rejection (X)

PHASE 4. Skills JSON Schema & Migration
4.1 Design skills.json schema: id, display_name, coeff, cast_time_ms, cooldown_ms, effects (X)
4.2 Implement schema_skills.h/.c: load/parse/validate/save with cross-reference checks (X)
4.3 Integrate with existing skills registry and coefficient system (X)
4.4 Add live reload capability with cache invalidation and derived data rebuild (X)
4.5 Tests: skills load/validate/save/reload, cross-ref validation, live reload (X)

PHASE 5. Overlay UI Framework Core
5.1 Implement overlay_core.h/.c: lifecycle, F1 toggle, panel registry (Done – lifecycle/init/shutdown, enabled flag, panel registry, new_frame/render hooks; F1 wired)
5.2 Add overlay_widgets.h/.c: Label, Button, Checkbox, SliderInt/Float, InputText (Done – basic immediate‑mode widgets implemented; headless-safe rendering guards)
5.3 Implement basic layout: BeginPanel/EndPanel, columns/rows, automatic wrapping (Done – Begin/End panel, vertical stacking, and columns begin/next/end implemented; widgets now auto-advance across columns and wrap to the next row. Row height now tracks tallest widget in the row for correct spacing.)
5.4 Add input handling: mouse/keyboard capture, focus management, text editing (Done – generalized Tab/Shift+Tab focus traversal across Button/Checkbox/Sliders/InputText; InputText caret navigation Home/End/Left/Right and insert/backspace at caret; Enter/Space activate buttons/checkboxes; sliders respond to Left/Right; click-to-focus added for all interactives; Tab navigation requests input capture.)
5.5 Tests: widget layout, input focus traversal, text input edge cases (Done – unit tests cover 2‑column wrap, focus/tab traversal, and caret edge cases. Tests: test_overlay_layout_focus, test_overlay_widgets, test_overlay_inputtext_caret.)

PHASE 6. Basic Overlay Panels
6.1 Implement System Panel: FPS, timings, memory usage, debug flags (Done – baseline System panel added and registered; shows FPS, frame time, draw calls, tile quads, and toggles metrics/overlay. Registered in app_init.)
6.2 Add Player Debug Panel: view/edit HP/MP/AP & core stats, god mode, noclip, teleport (Done – panel registered; sliders for HP/MP/AP and STR/DEX/VIT/INT; checkboxes for God Mode and No-clip; teleport helpers to spawn/center. Headless guards in widgets respected.)
6.3 Create player_debug.h/.c APIs for headless testing: get/set/teleport functions (Done – clamped setters; derived stat recompute on change; app-level flags for god_mode/noclip; teleport API; compiled into rogue_core.)
6.4 Wire F1 toggle in input system, ensure overlay consumes input when active (Done – F1 toggles overlay; event loop integrates overlay_input and gates gameplay on capture)
6.5 Tests: panel rendering, player debug APIs, input consumption (Done – overlay tests are green; `tests/unit/test_player_debug_api.c` covers clamps/derived recompute and god-mode damage bypass. Input capture/flag wiring validated in overlay tests.)

PHASE 7. Skills Manager Panel
7.1 Implement Skill Manager Panel: browse skills, edit coefficients/cooldowns (Done – initial panel added under Overlay Panels; select skill, edit timing and RogueSkillCoeffParams)
7.2 Add skill_debug.h/.c APIs: list/get/edit/simulate functions (Done – headless-safe APIs implemented and compiled into core; simulate wrapper calls rotation simulator)
7.3 Integrate with JSON save: live editing updates registry and writes to file (Done – added file-based loader `rogue_skill_debug_load_overrides_file(path)`, auto-load at app startup from env `ROGUE_SKILL_OVERRIDES` or default `build/skills_overrides.json`, and overlay panel gained Save/Load buttons targeting that path; atomic writes via json_io)
7.4 Add skill simulation: cast/channel testing with result preview (Done – panel exposes duration/ticks/AP regen/priorities; JSON summary output; deterministic unit tests added)
7.5 Tests: skill CRUD operations, JSON roundtrip, simulation accuracy (Partial – new unit test tests/unit/test_skill_debug_api.c validates list/get/set and simulate wrapper)

PHASE 8. Entity Inspector Panel
8.1 Design entities.json schema: id, name, group_min, group_max, patrol_radius, aggro_radius, speed, pop_target, xp_reward, loot_chance, base_level_offset, tier_id, archetype_id, optional texture path strings (Done – allow additional fields for now)
8.2 Implement schema_entities.h/.c: build schema and validate enemy type definitions (Done – save helpers TBD)
8.3 Add Entity Inspector Panel: table view with filters, kill/spawn/teleport (Done – initial panel wired; lists enemies, selection, Kill, Teleport to Player, and Spawn at Player actions. Headless guards respected.)
8.4 Create entity_debug.h/.c APIs: list/get/kill/spawn functions (Done – `rogue_entity_debug_count`, `rogue_entity_debug_list`, `rogue_entity_debug_get_info`, `rogue_entity_debug_teleport`, `rogue_entity_debug_kill`, `rogue_entity_debug_spawn_at_player` implemented against `g_app.enemies`.)
8.5 Tests: entity schema validation, inspector operations, spawn/kill effects (Done – headless units `tests/unit/test_entity_debug_api.c` and `tests/unit/test_entity_schema.c`; both green in Debug SDL2, -j12)

PHASE 9. Map Editor Panel
9.1 Design tilesets.json schema: id, tile_size, atlas, tiles array (Done – schema defined and documented in code; allows required fields and clamps ranges)
9.2 Implement schema_tilesets.h/.c: tileset loading and validation (Done – validator implemented with legacy CFG→JSON adapter and default assets check)
9.3 Add Map Editor Panel: tileset picker, brush size, paint/erase, layers (Partial – scaffolded panel registered; UI wiring skeleton and basic controls stubbed)
9.4 Create map_debug.h/.c APIs: load/save/set_tile/brush functions (Done – set_tile, brush_square, brush_rect, save_json, load_json with compact RLE)
9.5 Tests: tileset loading, map editing operations, save/load roundtrip (Done – `test_tilesets_schema` and `test_map_debug` cover validation and edit/persist round‑trip)

PHASE 10. Items Manager Panel
10.1 Add Items Manager Panel: browse items, edit stats/rarity/tags (X)
10.2 Implement item_debug.h/.c APIs: CRUD operations with validation (X)
10.3 Add live vendor inventory updates when items change (X)
10.4 Create item creation wizard: guided form with validation (X)
10.5 Tests: item CRUD, vendor sync, creation wizard validation (X)

PHASE 11. Advanced UI Widgets
11.1 Implement TreeNode/TreePop: hierarchical data display (X)
11.2 Add Table widget: sortable columns, row selection, filters (X)
11.3 Implement ColorEdit widget for visual debugging (X)
11.4 Add Combo/Dropdown widget for enum selection (X)
11.5 Tests: complex widget interactions, tree navigation, table sorting (X)

PHASE 12. Audio/VFX Debug Panel
12.1 Add Audio/VFX Panel: play sounds, spawn VFX at cursor, volume controls (X)
12.2 Implement audiovfx_debug.h/.c APIs: sound/effect testing functions (X)
12.3 Add asset reference validation for sounds and visual effects (X)
12.4 Create audio/VFX preview system with spatial positioning (X)
12.5 Tests: sound playback, VFX spawning, asset validation (X)

PHASE 13. Cross-Reference Validation System
13.1 Implement validation engine: check references across all JSON schemas (X)
13.2 Add real-time validation: display errors immediately in overlay (X)
13.3 Create dependency graph visualization for complex references (X)
13.4 Add batch validation tool for CI/automated testing (X)
13.5 Tests: cross-ref validation accuracy, error reporting, dependency tracking (X)

PHASE 14. Dynamic Content Creation
14.1 Add "New Entry" wizards for each content type with guided forms (X)
14.2 Implement template system: create new entries from existing templates (X)
14.3 Add validation pipeline: prevent saving invalid or conflicting content (X)
14.4 Create content export/import: share content packs between projects (X)
14.5 Tests: content creation workflows, template system, export/import (X)

PHASE 15. Performance & Polish
15.1 Optimize overlay disabled path: ensure <0.1ms overhead when inactive (X)
15.2 Add memory management: arenas/pools, minimize per-frame allocations (X)
15.3 Implement overlay_theme.h/.c: colors, spacing, fonts, visual polish (X)
15.4 Add keyboard navigation: tab traversal, hotkeys, accessibility (X)
15.5 Tests: performance benchmarks, memory leak detection, theme consistency (X)

PHASE 16. Advanced Features (Optional)
16.1 Add search/filter system: global content search across all schemas (X)
16.2 Implement command palette: quick actions and navigation (X)
16.3 Add macro recorder: capture and replay debug actions (X)
16.4 Create screenshot/recording helpers for debugging sessions (X)
16.5 Tests: search accuracy, command palette, macro playback (Optional)

PHASE 17. Headless Testing Integration
17.1 Implement overlay_invoke_action API for programmatic control (X)
17.2 Add test fakes: in-memory filesystem, mock rendering (X)
17.3 Create comprehensive test suite covering all debug APIs (X)
17.4 Add CI integration: automated overlay testing in headless mode (X)
17.5 Tests: full headless test coverage, CI pipeline validation (X)

PHASE 18. Extensions & Future Work (Optional)
18.1 Design undo/redo system: command pattern with capped history (Optional)
18.2 Add networked debug overlay: remote control via TCP/WebSocket (Optional)
18.3 Implement scriptable actions: Lua or custom scripting for debug tasks (Optional)
18.4 Add profiler integration: CPU/GPU traces in overlay UI (Optional)
18.5 Tests: extension functionality, network security, script safety (Optional)
