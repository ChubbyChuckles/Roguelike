AUDIO & VFX PIPELINE IMPLEMENTATION PLAN (Roadmap & Status)

Legend:
Done = Fully implemented & tests pass
Partial = Some components implemented (details in parentheses)
X = Not started yet

Scope Overview:
Unified event-driven audio & visual effects pipeline decoupled from gameplay logic. Goals: minimal latency, pooling, layering, deterministic replay, data-driven authoring, dynamic mixing (ducking, side-chain), adaptive effects scaling (performance modes), and robust headless validation of emission ordering.

PHASE 0. Current Baseline (Partial)
0.1 SDL_mixer init & basic sound load (Partial)
0.2 Hit damage numbers (visual feedback partial) (Partial)
0.3 Simple level-up sound stub (Partial)

PHASE 1. Core Event System
1.1 Define EffectEvent struct (type, payload, timing) (Done)
1.2 Global effect bus queue with double-buffer (Done)
1.3 Submission API: rogue_fx_emit(..) deterministic ordering (Done)
1.4 Priority & channel classification (combat, ui, ambience) (Partial: enums, basic sort)
1.5 Frame compaction (merge duplicates) (Done)

PHASE 2. Audio Subsystem Foundations
2.1 AudioRegistry (sound id -> metadata: path, category, volume base) (Done: minimal; loads Mix_Chunk when SDL_mixer)
2.2 Lazy loading & hot reload detection (X)
2.3 Channel mixer (gain per category, master mute) (X)
2.4 Voice pool & polyphony limiting (X)
2.5 Randomized multi-sample selection (variation) (X)
2.6 2D positional panning & distance attenuation stub (X)
2.7 Deterministic seed mapping for repeated events (X)

PHASE 3. VFX Subsystem Foundations
3.1 VfxRegistry (effect id -> script: sprite sequence / particles) (X)
3.2 Particle system core (emitters, spawn rate, lifetime) (X)
3.3 Object pool for particles & sprite instances (X)
3.4 Layer ordering (background, mid, foreground, UI) (X)
3.5 Time scaling integration (hitstop freeze) (X)
3.6 Screen-space vs world-space coordinate support (X)

PHASE 4. Authoring & Data Format
4.1 Config schema (e.g. assets/fx/*.cfg) (X)
4.2 Hot reload & validation errors reporting (X)
4.3 Effect composition: chain & parallel blocks (X)
4.4 Parameter overrides (color shift, scale, lifetime) (X)
4.5 Random distributions (uniform, normal) for variation (X)

PHASE 5. Binding Gameplay to Effects
5.1 Mapping table: gameplay event -> effect id(s) (X)
5.2 Damage event hook (per damage type layering) (X)
5.3 Skill activation start/end cues (X)
5.4 Buff gain/expire triggers (X)
5.5 Loot drop rarity color + sparkle effect (X)
5.6 Vendor restock & level-up celebration (Partial: level-up sound)

PHASE 6. Advanced Audio Features
6.1 Dynamic music state machine (explore, combat, boss) (X)
6.2 Cross-fade & beat-aligned transitions (X)
6.3 Side-chain ducking (e.g., UI or key SFX lower music) (X)
6.4 Procedural layering (combine base + random sweeteners) (X)
6.5 Reverb / environmental preset stubs (toggle simulation) (X)
6.6 Distance-based low pass filter attenuation (X)

PHASE 7. Advanced VFX Features
7.1 GPU-friendly batched sprite particle update (future hook) (X)
7.2 Additive & multiplicative blend modes (X)
7.3 Motion vectors / trail emitters (X)
7.4 Screen shake manager (priority stacking) (X)
7.5 Post-processing: bloom stub & color grade LUT application (X)
7.6 Performance scaling: degrade particle counts when FPS low (X)
7.7 Decal / ground projection system (X)

PHASE 8. Performance & Budgeting
8.1 Per-frame effect cost profiler (spawn counts, active particles) (X)
8.2 Soft & hard budgets (drop or LOD effects) (X)
8.3 Frame pacing guardrails (defer heavy spawns) (X)
8.4 Pool fragmentation audit tool (X)
8.5 Stress test scenario (100 simultaneous impacts) (X)

PHASE 9. Determinism & Replay
9.1 Deterministic ordering: stable sort by (emit_frame, priority, seq) (X)
9.2 Replay log serializer (effect events only) (X)
9.3 Hashing of event stream for test validation (X)
9.4 Divergence detector (compare live vs expected hash) (X)

PHASE 10. Tooling & Debugging
10.1 In-game effect console (play <id>, list, mute) (X)
10.2 Overlay: particle bounds, counts, emitter debug (X)
10.3 Audio channel meters (peak, RMS) (X)
10.4 Leak detector (pool objects not recycled) (X)
10.5 Config validation CLI tool (X)

PHASE 11. Testing & QA
11.1 Unit tests: registry parsing, pooling reuse, event ordering (X)
11.2 Fuzz: randomized spawn patterns ensuring no crashes (X)
11.3 Load test harness auto-screenshot & hash (VFX) (X)
11.4 Determinism test: same seed -> identical event hash (X)
11.5 Budget test: spawn beyond soft limit -> correct drop rate (X)

PHASE 12. Accessibility & UX Considerations
12.1 Master SFX/music/UI volume sliders (X)
12.2 Loudness normalization (integrated gain pass) (X)
12.3 Screen flash reduction (comfort mode) (X)
12.4 Colorblind-friendly particle palette variants (X)
12.5 Motion sickness mitigation (reduced shake) (X)

PHASE 13. Documentation
13.1 Authoring guide (config syntax, best practices) (X)
13.2 Performance tuning checklist (X)
13.3 FAQ / troubleshooting (no sound, missing assets) (X)

DEPENDENCIES / RISKS
- Particle batching complexity; may defer GPU path.
- SDL_mixer feature limits (advanced DSP) -> may need abstraction.
- Deterministic ordering must handle concurrent emission gracefully.

SUCCESS METRICS
- <2ms average total audio+VFX CPU under standard combat scenario.
- 100 impact stress test remains within frame budget (no >5% frame spikes).
- Replay hash stable across 10 consecutive runs.

NEXT ACTION CANDIDATES
- Implement Phase 1 + 2 minimal: event bus + basic registry + play sound. (Completed)
- Add particle pool stub & single sparkle effect for loot drop. (Pending; tie into VFX dispatch)

Notes (2025-08-24):
- Added src/audio_vfx/effects.[ch] providing RogueEffectEvent, rogue_fx_emit, frame begin/end, dispatch, and a simple digest (rogue_fx_get_frame_digest).
- Wired app step to tick the FX bus each frame and process dispatch before present.
- Registered LEVELUP sound from assets/sounds.cfg into audio registry and routed level-up cue via bus.
- New unit test tests/unit/test_audio_vfx_phase1_2.c validates deterministic digest ordering.
 - Implemented frame compaction in dispatcher: identical events (type+priority+id) within a frame are merged and tracked via 'repeats'. Digest now includes repeat count. Added tests/unit/test_audio_vfx_phase1_5_compaction.c and registered with CTest.
\n+CROSS-SYSTEM SYNERGIES (Added)
Ordering (Frame Pipeline): Collect Gameplay Events -> Normalize & Tag (rarity, biome, material) -> Priority Sort (critical/combat/ui/ambience) -> Budget Cull & Merge -> Dispatch (Audio Mixer / VFX Spawner) -> Instance Update & Lifetime Advance -> Frame Digest Hash Emit.
Inputs Consumed:
 - Combat & Skill: damage_applied, status_proc, cast_phase markers control layered cues (pre-cast, impact, resolve) ensuring synch with hitstop.
 - Equipment & Loot: rarity tier & unique flags drive flourish intensity; proc triggers schedule chained sweetener sounds.
 - AI & World Generation: ambient zone tags (biome, structure) select looping ambience & reverb preset; AI shouts & boss phase transitions raise high-priority ducking events.
 - Persistence/Replay: recorded effect events injected verbatim for determinism validation.
Outputs Provided:
 - Frame effect digest contributes to global integrity chain (H(sorted_event_ids, culled_count, active_voice_ct, active_particle_ct)).
 - Telemetry events (budget_overflow, cull_applied, voice_steal) feed Maintainability analytics & balancing review.
Integrity & Determinism:
 - Stable ordering tuple = (emit_frame, priority, sequence_id); strictly monotonic sequence per producer stream prevents nondeterministic ties.
 - Cross-system replay test: feed captured combat log; expect identical digest across platforms.
Risk Mitigation:
 - Proc chain explosion: per-frame spawn quota & merge strategy (coalesce identical visual within N ms -> intensity scalar ramp). Prevents visual spam & audio clipping.
 - Latency regression guard: probe measuring queue submit -> mixer dispatch; telemetry if >5ms three consecutive frames.
Open Tasks:
 - Expose audio_vfx_get_frame_digest() API for unified replay harness.
 - Add cross-test linking loot generation of unique drop to expected flourish sequence & digest delta.
Change Impact: Documentation only; follow-up adds API & tests.
