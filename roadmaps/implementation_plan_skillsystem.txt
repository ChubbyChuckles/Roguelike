SKILL / BUFF / DEBUFF SYSTEM IMPLEMENTATION PLAN (Roadmap & Status)

Legend:
Done = Fully implemented & tests pass
Partial = Some components implemented (details in parentheses)
X = Not started yet

Scope Overview:
A multi-layer system enabling active skills, passive talents, triggered procs, stacking buffs, debuffs, crowd control (CC), damage over time (DOT), area auras, conditional synergies, and data-driven configuration. Designed for determinism, testability, and future multiplayer authority.

PHASE 0. Current Baseline (Done)
0.1 Skill registry with dynamic array, rank progression, cooldown logic (Done)
0.2 Passive skill synergy bucket accumulation (Done)
0.3 Basic activation callback with deterministic context (Done)
0.4 Fixed cooldown override for tests (ROGUE_TEST_SHORT_COOLDOWNS) (Done)
0.5 Simple timed buff list with stacking by type & magnitude extension (Done)

PHASE 1. Core Refactor & Data Model Expansion (No Global Cooldown – action economy focus)
1.1 Enumerate skill categories & elemental/utility tags (fire, frost, arcane, movement, defense, support, control) (Partial: tags added to header)
1.2 Introduce unified EffectSpec structure (instant, DOT, HOT, aura, CC, stat_mod, projectile, chain, summon) (Partial: minimal registry + STAT_BUFF kind + skill linkage + test)
1.3 Extend RogueSkillDef: resource_cost, charges, charge_recharge_ms, action_point_cost, cast_time_ms, cast_type (instant|cast|channel), input_buffer_ms, max_simultaneous_channels, combo_point_builder/spender flags (Partial: added cast_time_ms & cast_type with basic cast/channel handling + tests; input buffer implemented via queued_trigger_ms; combo builder/spender applied on instant/cast-complete/channel-tick, combo capped at 5)
1.4 Add RogueSkillState: charges_cur, last_cast_ms, cast_progress_ms, channel_end_ms, queued_until_ms, action_points_spent_session, combo_points_accum (Partial: casting/channel flags & progression implemented; input queue implemented via per-skill queued_trigger_ms; combo logic integrated)
1.5 Action Point (AP) economy core: regen rate, cap, per-skill AP cost; soft throttle (Done: core + soft throttle + tests)
1.6 Deterministic RNG hook per activation (seed derivation) (Done)
1.7 Unit tests: charge recharge, AP insufficiency rejection, cast queue window, channel interruption, combo builder -> spender flow (Partial: charge + mana cost test added)

PHASE 1A. Temporal Pacing Enhancements
1A.1 Input buffering & latency compensation window (queue skill within N ms of cast finish) (Done: per-skill queued_trigger_ms, triggers after prior cast completes; validated in `test_skills_phase1a_buffer_weave_combo` and `test_input_buffer_cast`)
1A.2 Cast weaving rules: prevent two identical archetype casts below a minimum separation unless haste threshold reached (Done: min_weave_ms gate for casted skills; haste override using POWER_STRIKE >= 10 allows bypass; validated in `test_skills_phase1a_buffer_weave_combo` and `test_cast_weave_and_cancel`)
1A.3 Adaptive haste windows: temporary acceleration buffs adjust cast_time_ms & AP regen snapshot vs dynamic evaluation modes (Done: snapshot flags on `RogueSkillDef.haste_mode_flags` — bit 0 = CAST, bit 1 = CHANNEL; runtime snapshots stored in `RogueSkillState.haste_factor_cast`/`haste_factor_channel`; dynamic path reads live buffs when flags are unset)
1A.4 Early cancel windows (cast trimming): partial effect scaling (e.g., 70% progress grants 50% effect) (Partial: cancel API with linear scalar, min progress pct; integrated into weave test; standalone coverage in `test_cast_weave_and_cancel`)
1A.5 Channel tick scheduler decoupled from frame time (fixed tick quantum with drift correction) (Done: fixed 250ms base quantum with drift-corrected scheduling anchored to `channel_start_ms`; next tick computed from ideal schedule, not last tick time)
1A.6 Tests: buffered queue ordering, haste snapshot determinism, early cancel scaling accuracy, channel tick drift bounds (Done: added `tests/unit/test_skills_phase1a_haste_snapshot_and_drift.c` verifying cast snapshot immunity to mid-cast haste, channel snapshot exact ticks (4 in 1000ms), dynamic channel >= baseline under mid-channel haste; existing buffer/weave/cancel tests remain)

PHASE 1.B. Skill Tree / Talent Graph (Early Skeleton - Open Allocation)
1B.1 Minimal DAG data model: node, directed edge, node types (stat_bonus, skill_unlock, modifier, keystone, mastery) and lightweight adjacency list for lookup (Done: header enum + runtime storage for node types; explicit per-node AND prerequisites via API; skill unlock mapping; queries implemented; validated in `test_talents_phase1b_dag_and_modifiers`)
1B.2 Open-allocation rule set: no mutually-exclusive branches; unlocking requires inbound prerequisites OR meeting a cumulative predecessor-point threshold (supports AND + threshold ANY) (Partial: ANY-threshold gating implemented with `rogue_talents_set_any_threshold`; unit test `test_talents_phase1b_open_allocation` passes)
1B.3 Node modifier primitives: cooldown scalar, AP cost delta, add EffectSpec reference, tag injection, charge +1, conditional proc chance (Done: cooldown scalar, AP delta, tag injection, charges +1, and effect override applied in `rogue_skill_get_effective_def`; reserved proc chance present; validated by skeleton and DAG+modifiers tests)
1B.4 Point economy (phase-1): single `talent_points` pool + simple rank costs and optional regional point buckets for keystones (Partial: cost-aware unlocks implemented via progression meta `cost_points` with default=1; deducted on unlock; covered by `test_talents_phase1b_open_allocation`)
1B.5 Respec UX & API: preview mode (no commit), commit/respec endpoints, partial refund for last N nodes, full respec cost scaling with total spent (Partial: implemented preview begin/unlock/cancel/commit and respec_last/full_respec APIs; preview journal now stores attribute context and commit uses captured values; unit tests added/passing in Debug with SDL2 -j8; UI & cost scaling deferred)
1B.6 Serialization skeleton: versioned blob header + node_count + compact unlocked bitset + varint ranks; reserve forward-compatible bytes (Done: header v2 + unlocked bitset + varint ranks implemented with v1 back-compat mapping unlocked→rank=1; validated by `test_talents_phase1b_ranks_and_hash`)
1B.7 Deterministic hash: stable hash over sorted (node_id,ranks,version) for replay / diagnostic checks (Done: hash now folds version marker and non-zero ranks ensuring stability independent of unlock order; validated alongside 1B.6 test)
1B.8 Runtime hooks: unlock API, query unlocked nodes, apply node modifiers to `RogueSkillDef` live view with snapshot_on_activate vs dynamic flags (Partial: unlock API + query helpers present, modifier application implemented for live view; snapshot flags hookup later)
1B.9 Tests (phase-1): prerequisite enforcement (AND + threshold), open-allocation validation (no false exclusion), serialization round-trip, hash stability, modifier propagation to runtime skill data (Done: added `test_talents_phase1b_dag_and_modifiers`; existing open_allocation, skeleton, respec/preview cover others; hash/serialize covered in skeleton)
1B.10 Performance & safety: micro-bench unlock + respec + serialize target <0.1 ms typical; reserve simple limits to avoid pathological autodiscovery (X)
1B.11 Integration note: design for eventual synergy-bucket hooks (Phase 1 partial synergy integration) and keep UI/analytics hooks minimal (X)

PHASE 2. Resource & Cost Layer
2.1 Player resource pools extension (stamina, energy, heat, focus, combo_points) (X)
2.2 Cost mapping per skill (flat, percent max, scaling-with-rank, conditional surcharge) (X)
2.3 Refund & partial refund mechanics on miss / resisted / early cancel (X)
2.4 Overdrive & Exhaustion: temporary resource ceiling raise + post-burn recovery penalty (X)
2.5 Heat / Overheat loop (build heat -> unlock empowered variant -> vent) (X)
2.6 Tests: insufficient resource rejection, refund tiers, overdrive decay, heat overflow clamp (X)

PHASE 3. Effect Processing Pipeline
3.1 EffectSpec parser (in-memory static array first; file/data-driven later) (X)
3.2 Multi-stage application pipeline: preconditions -> snapshot -> schedule -> resolve (deterministic order) (X)
3.3 Stacking rules: unique, additive, multiplicative, refresh_only, extend_duration, replace_if_stronger (X)
3.4 Snapshot vs dynamic scaling flags (per attribute granularity) (X)
3.5 Periodic tick scheduler (hierarchical timing wheel + coalesced batch execution) (X)
3.6 Effect graph composition (parent -> child chained effects with delay offsets) (X)
3.7 Tests: stacking variants, partial snapshot mixture, tick ordering determinism, chained delay accuracy (X)

PHASE 4. Buff System Upgrade
4.1 Replace fixed-size array with ring-buffer or handle-based pool + free list (X)
4.2 Buff handle API (apply, refresh, remove, query) (X)
4.3 Category fields: offensive, defensive, movement, utility (X)
4.4 Expiration callbacks (on_expire) for triggered effects (X)
4.5 Diminishing returns (DR) tracker for CC categories (stun, root, slow) (X)
4.6 Tests: DR decay, expiration triggers, handle reuse safety (X)

PHASE 5. Debuffs & Damage Over Time
5.1 Separate namespace / flag for debuffs (harmful) (X)
5.2 DOT tick engine: base_damage, scaling coefficients (stat-sourced) (X)
5.3 Resist / mitigation pipeline hook integration (armor, resist stats) (X)
5.4 Critical tick chance (roll per application vs per tick configurable) (X)
5.5 Tests: DOT duration, stacking model (refresh vs extend), crit variance determinism (X)

PHASE 6. Auras & Area Effects
6.1 Aura definition: radius, pulse_period_ms, entry/exit callbacks (X)
6.2 Spatial indexing hook for fast entity inclusion (reuse vegetation or new grid) (X)
6.3 Aura stacking & exclusivity groups (X)
6.4 Tests: entry/exit ordering, pulse timing determinism (X)

PHASE 7. Proc & Trigger System
7.1 Event bus enumeration (on_hit, on_crit, on_kill, on_damage_taken, on_tick, on_channel_tick, on_resource_threshold, on_combo_spend) (X)
7.2 Proc definition: condition predicate + effect reference + internal cooldown (ICD) + per-target ICD (X)
7.3 Probability weighting with deterministic RNG sequence & variance smoothing (X)
7.4 Anti-proc loop guard (depth counter + cycle hash) (X)
7.5 Dynamic proc scaling (recent activity weighted) (X)
7.6 Tests: ICD enforcement (global & per-target), probability distribution stability, loop guard, variance smoothing bounds (X)

PHASE 8. Scaling & Coefficients
8.1 Central coefficient table keyed by skill id + rank (X)
8.2 Stat contribution flags (strength->physical, intelligence->arcane, dexterity->crit) (X)
8.3 Soft caps & diminishing returns curves (logistic / piecewise) (X)
8.4 Tests: coefficient application, soft cap flattening, rank progression scaling (X)

PHASE 9. Persistence & Serialization
9.1 Serialize extended skill state (charges, cooldowns, ICD timers) (X)
9.2 Serialize active buffs/debuffs (type, magnitude, remaining_ms, stacking id) (X)
9.3 Version tagging + migration handlers for new fields (X)
9.4 Tests: round-trip with mid-cooldown and active DOTs (X)

PHASE 10. Tooling & Data-Driven Content
10.1 External skill config (CSV/JSON) for definitions & coefficient sets (X)
10.2 External effect config: EffectSpec list with stacking & flags (X)
10.3 Validation tool: detect invalid references, cyclic procs, missing coefficients (X)
10.4 Auto-doc generator for skill sheets (X)
10.5 Tests: parser edge cases, invalid reference rejection (X)

PHASE 11. Visualization & UI Enhancements
11.1 Cooldown & cast-time dual progress (sweep + bar) (X)
11.2 Buff/debuff icon bar with stack counts, duration mini-bars, source coloring (X)
11.3 Aura & channel area debug overlay with falloff gradient (X)
11.4 Proc & combo spend floating indicators (sequenced fade) (X)
11.5 Action Point & resource delta ticker (gain/spend pulses) (X)
11.6 Tests: icon ordering, expired removal, cast progress sync, AP delta batching (X)

PHASE 12. Advanced Mechanics
12.1 Channelled skills (begin/end/interrupt, partial credit) (X)
12.2 Input queue latency buffer + predictive pre-cast stub (X)
12.3 Snapshotting modes: full, partial (per-coefficient mask), dynamic (X)
12.4 Cross-skill synergy triggers & conditional dependency graph (X)
12.5 Conditional modifiers (target state, resource thresholds, time-since-last-hit) (X)
12.6 Multi-phase skills (startup, travel, impact, aftermath) with overridable sub-effects (X)
12.7 Tests: channel interruption, conditional evaluation ordering, multi-phase determinism (X)

PHASE 13. Performance & Memory
13.1 Buffer pool for periodic tick events (X)
13.2 SoA layout for active effects for cache-friendly ticking (X)
13.3 SIMD batch damage calculations (optional) (X)
13.4 Micro-profiler integration for per-phase timing (X)
13.5 Tests: stress (1000 active DOTs) performance budget enforcement (X)

PHASE 14. Security / Determinism / Multiplayer Prep
14.1 Deterministic RNG streams separated: activation, periodic ticks, procs, proc-variance smoothing (X)
14.2 Hashing of effect & resource transaction events for replay validation (X)
14.3 Authority validation stubs (server vs client predicted) (X)
14.4 Anti-speed-hack delta clamp (cooldowns, AP regen, channel ticks) (X)
14.5 Tests: deterministic replay, hash mismatch detection, AP regen clamp (X)

PHASE 15. Analytics & Telemetry
15.1 Per-skill usage counters & DPS contribution breakdown (X)
15.2 Buff uptime tracker (percentage over session) (X)
15.3 Proc efficiency metrics (trigger attempts vs successes) (X)
15.4 Export JSON snapshot for balancing dashboards (X)
15.5 Tests: uptime calculation accuracy, usage counter persistence (X)

PHASE 16. Polish & Balancing Aids
16.1 Action queue & cast buffering visualization (X)
16.2 Recommended next-skill helper (priority scoring & AP projection) (X)
16.3 Loadout presets save/load (skills + effect graph selections) (X)
16.4 Passive tree planner (offline simulation) (X)
16.5 Automated rotation simulator (expected DPS / AP curve) (X)
16.6 Tests: preset round-trip, rotation simulation determinism, recommendation stability (X)

PHASE 17. Skill Tree / Talent Graph System (Open Allocation – No Classes / No Exclusivity)
17.1 Data Model: DAG-based talent graph (nodes, edges) with node types (stat_bonus, skill_unlock, modifier, keystone, mastery) (X)
17.2 Node Layout & Coordinates: logical grid positions + path cost; sparse adjacency list for memory efficiency (X)
17.3 Pathing Rules: unlock requires all inbound prerequisites OR meeting a cumulative point threshold in predecessor set (supports AND & threshold-based ANY without exclusion) (X)
17.4 Open Allocation Philosophy: zero mutually exclusive branches; design relies on distance (path cost) + diminishing returns to create opportunity cost instead of hard locks (X)
17.5 Keystone Mechanics: powerful nodes with gating (regional points spent, minimum level, resource threshold); all keystones can coexist if requirements met (X)
17.6 Regional Affinity Buffs: passive scalar bonuses escalating with invested points; soft caps & diminishing returns curve to prevent runaway stacking (X)
17.7 Mastery Nodes: repeatable investment (ranked) with escalating cost curve (quadratic / custom) & diminishing incremental benefit (X)
17.8 Conditional Unlocks: gating by player level, quest flag, challenge completion, or discovered lore (X)
17.9 Flexible Respec: free preview (no commit until confirm); partial refund last N nodes; full respec cost scales with total spent (no exclusivity rollback logic needed) (X)
17.10 Point Economy: multiple pools (talent_points, mastery_points) + optional time‑gated bonus points (weekly cap) (X)
17.11 Node Modifiers to Skills: references apply: cooldown scalar, AP cost delta, add EffectSpec, tag injection, charge +1, conditional proc chance (X)
17.12 Synergy Bucket Integration: node ranks add synergy; keystone conditional multipliers (e.g., +20% fire synergy if >=10 fire-tag nodes unlocked) (X)
17.13 Snapshot vs Live Flags: node attributes marked snapshot_on_activate or dynamic_read to control performance & determinism (X)
17.14 Serialization: versioned blob (header + node_count + bitset unlocked + varint ranks) with forward-compatible reserved bytes (X)
17.15 Deterministic Hash: stable hash over sorted (node_id,ranks,version) for replay / anti-cheat (X)
17.16 UI Layer: zoom/pan canvas, search filter, prerequisite overlay, path highlight on hover, region heat coloring by investment density (X)
17.17 Accessibility: color-blind safe palette, scalable vector icons, keyboard / controller navigation focus ring (X)
17.18 Analytics: node popularity, abandonment (% respecced), marginal efficiency (benefit per point), regional investment distribution (X)
17.19 Balancing Tooling: offline Monte Carlo & heuristic optimizers to map reachable stat envelopes & detect degenerate stacking (X)
17.20 Tests: prerequisite enforcement (AND + threshold), open-allocation validation (no false exclusion), mastery scaling curve, serialization round-trip, hash stability, respec refund accuracy, modifier propagation to runtime skill data (X)
17.21 Performance: micro-bench unlock + respec + serialize (<0.1 ms target typical tree) (X)
17.22 Future Extension Hooks: seasonal overlay nodes (additive), event-limited temporal nodes (auto-expire), metamorph node evolution after condition (X)

PRIORITY NEAR-TERM SUBSET
- Phase 1 (1.1 – 1.7): Foundation extensions (tags, EffectSpec, charges, AP economy, deterministic RNG)
- Phase 1A (1A.1 – 1A.6): Temporal pacing (buffering, weaving, haste, channels)
- Phase 2 (2.1 – 2.6): Extended resource models (heat, combo, overdrive)
- Phase 3 (3.1 – 3.7): Effect pipeline & composable graphs
- Phase 4 (4.1 – 4.6): Buff system overhaul with handles & DR
- Phase 17 (17.1 – 17.5 initial): Core talent graph skeleton & serialization groundwork

NOTES
- Maintain strict determinism: capture seed states for activation, periodic ticks, and AP regen slices.
- Early micro-bench harness for EffectSpec batching & channel tick scheduler.
- Reserve padding in structs for forward-compatible additions (version tags for persistence).
- Hide internal arrays & pools in .c files; expose narrow C API surfaces.
- Provide simulation scripts for rotation & resource curves before tuning live values.
\nCROSS-SYSTEM SYNERGIES (Added)
Ordering (Effect Resolution): Base Stats (Equipment + Progression) -> Skill Coefficients & Talent Modifiers -> Proc/Passive Synergy Buckets -> Buff/Debuff Layer -> Dungeon/Mutator Scalars -> Enemy ΔL & Adaptive Difficulty -> Final Mitigation / Caps.

Inputs Consumed:
 - Progression: Attribute & passive node modifiers feed coefficient scaling; mastery ranks may unlock additional EffectSpec variants while respecting snapshot/dynamic flags.
 - Equipment: Affix & proc engine contribute pre-skill layer stat modifications; equipment procs can inject temporary buffs that the skill system treats as dynamic layer entities.
 - Combat: Provides timing windows (i-frames, stagger) influencing applicability of certain instantaneous or channel ticks; skill cancel rules align with combat reaction states to avoid desync.
 - Inventory / Crafting: Enhancement operations (imbue/temper) may tag skills or add conditional proc hooks (tag injection path) referencing skill tag taxonomy.
 - Dungeon & Mutators: Inject run-level global effect scalars or conditional triggers (e.g., +X% DOT tick rate) processed after base skill + progression layers.
 - Enemy Difficulty: ΔL model influences enemy mitigation & resistance curves which the skill system queries for DOT tick mitigation and CC DR stacking windows.
 - Vendor / World Boss: Boss defeat tokens unlock skill variant definitions (EffectSpec entries) and vendor offers provide temporary skill augmentation items (time-limited buff items) consumed as dynamic buff layer entries.

Outputs Provided:
 - Per-skill usage & DPS contribution metrics consumed by balancing dashboards, progression anomaly detection (sudden power spikes), and vendor recommendation engines (offer complementary items to underused archetypes).
 - Active buff/debuff snapshot hash used by world boss encounter hash and death recap panel.
 - Proc efficiency stats inform equipment proc balance & crafting enhancement risk tuning.

Integrity & Determinism:
 - Unified effect_event_hash = H(activation_id, seed_stream_ids, effect_specs_sorted, snapshot_stat_vector_hash) exported for replay harness & cross-system validation.
 - Snapshot vs dynamic misconfiguration test ensures no dynamic flag effect modifies historical snapshot hash mid-duration (prevents exploit via re-spec while effect active).

Risk Mitigation Cross-System:
 - Prevent multiplicative stacking runaway: enforce layering rule (progression * (1 + equipment_add + skill_add + buff_add)) then apply dungeon/mutator multiplier with cap; CI test enumerates extreme combination envelope.
 - Proc Storm loops (equipment proc triggers skill proc triggers equipment): loop guard depth counter + cycle hash shared with equipment system.
 - Tag Drift: Maintain central tag registry JSON (skills/equipment/dungeon) with versioned hash; skill load fails if registry hash mismatch outside migration path.

Open Tasks:
 - Expose C API: skill_simulate_rotation(profile_json).
 - Add registry: tag_registry.json with cross-system validation tool.
 - Add test: cross-layer ordering invariance (swap equipment vs progression application order -> identical final coefficient vector).

Change Impact: Documentation only; future commits will implement APIs, registry, and tests.

Updates (Current Commit):
- Exposed C APIs Completed:
	- skill_export_active_buffs_hash(now_ms): returns FNV-1a 64 hash over active buffs snapshot (type, magnitude, snapshot flag, remaining_ms). Used for replay/analytics integrity.
	- skill_get_effective_coefficient(skill_id): multiplies mastery and specialization damage scalars to produce an overall coefficient for the given skill id.
- Tests: Added tests/unit/test_skills_phase2_api.c validating non-zero and time-varying buff hash and basic coefficient sanity; integrated into CMake (Debug, SDL2, -j8 build passes).
- Next: skill_simulate_rotation(profile_json) (stub remains), tag_registry.json + validation tool, and cross-layer ordering invariance test.
