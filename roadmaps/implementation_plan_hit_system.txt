HIT SYSTEM REWORK IMPLEMENTATION PLAN (Weapon-Length, Directional, Overlap-Based, VFX/SFX Feedback)

Legend:
Done = Fully implemented & validated
Partial = Some components implemented (details)
X = Not started

Objective Summary:
Replace current abstract strike timing / implicit reach logic with a physically grounded, weapon-length driven hit detection system that:
- Models a per-frame weapon sweep volume based on weapon length and orientation.
- Detects overlap with enemy hitboxes from any direction (full 360° coverage).
- Plays directional impact SFX, damage flash (single blink), particle burst along hit normal.
- Applies knockback scaled by level & strength differential.
- Triggers enemy explosion effect if one-shot (overkill condition) distinct from standard death.
- Provides debug overlay toggling weapon & enemy bounding volumes and slash animation frames.
- Renders an 8-frame slash VFX sheet with weapon sprite overlaid and pose-corrected (x,y,theta per frame).

PHASE 0. Baseline Audit & Decomposition (Immediate)
0.1 Inventory current hit logic: identify strike activation window, reach calc, current damage application site (combat / enemy_system_ai intersection).
0.2 Enumerate data already available: player facing vector, weapon archetype stats, enemy AABBs or position+radius, combo state.
0.3 Confirm existing knockback & critical/overkill pipeline endpoints.
0.4 Gather existing rendering hooks for debug draw & damage flash (tint/flash_timer).
Deliverable: summary doc in docs/hit_system_audit.md (optional) (X)

PHASE 1. Data Structures & Configuration (Done)
1.1 Weapon geometry struct: length_px, width_px (for capsule), pivot_offset (from player origin), slash_vfx_id.
1.2 Enemy hitbox standardization: ensure each enemy exposes canonical hurt AABB and derived capsule (center,radius,height) if vertical layering needed.
1.3 Slash animation table: 8 entries with per-frame weapon overlay transform {dx, dy, angle_deg, scale}.
1.4 Authoring format (JSON): weapons_hit_geo.json & slash_vfx_overlays.json with arrays keyed by weapon_type / vfx_id.
1.5 Loader functions with fallback logging & validation (length>0, frame count==8).
1.6 Tests: load valid JSON, reject malformed, ensure overlay frame count. (X)

PHASE 2. Runtime Hit Volume Generation (Done)
2.1 Represent weapon sweep this frame as capsule: start = player_pos + pivot_offset, end = start + facing * length_px.
2.2 During strike phase only: compute instantaneous capsule; optionally expand slightly for fast weapons (speed scalar * 0.1 * length) to mitigate tunneling.
2.3 Multi-frame accumulation: maintain last capsule and union test for enemies not yet hit (one-hit per strike unless multi-hit weapon flag later).
2.4 Debug overlay: append capsule to debug draw list (color: cyan) when hit_debug enabled.
2.5 Tests (unit): geometric overlap between capsule and synthetic enemy AABB / circle across directions (N,E,S,W, diagonals). (X)

PHASE 3. Overlap Detection Pipeline (Done)
3.1 Broadphase: AABB of capsule vs enemy AABB array (reuse or add lightweight loop; small enemy counts justify O(n)).
3.2 Narrowphase: capsule vs AABB intersection (segment distance <= (weapon_width/2 + enemy_padding)).
3.3 Directional normal: compute from enemy center to closest point on segment; normalize for VFX emission direction & knockback.
3.4 Maintain per-strike hit registry (enemy id bitset) to prevent duplicate hits.
3.5 Expose API rogue_combat_weapon_sweep_apply(dt_ms) returning hit count.
3.6 Tests: ensure no double hits, directional coverage 360°, correct normal sign. (X)

PHASE 4. Feedback: SFX, Flash, Particles, Knockback (Done)
4.1 Impact SFX: add sound id table per weapon archetype; play on first enemy hit only (or every hit with cooldown 40ms) via rogue_audio_play_sfx().
4.2 Damage flash: set enemy->flash_timer = FLASH_MS (e.g., 120) & toggle tint flag; existing render path will blink once.
4.3 Particle emission: spawn N (8–14) particles at impact point; velocity base = normal * base_speed plus random lateral spread (rotate ±35°). Color from enemy palette or damage type.
4.4 Knockback magnitude: base = clamp( (player_level - enemy_level)*level_scalar + (player_str - enemy_str)*stat_scalar , min_knockback, max_knockback ). Negative or small => minimal push.
4.5 Apply knockback impulse: enemy->base.pos += normal * magnitude (implemented inline in combat_strike using refined magnitude).
4.6 Overkill explosion: execution / overkill sets explosion flag + spawns larger particle burst (screen shake deferred to later tuning iteration).
4.7 Tests: knockback scaling / cap, particle counts (normal vs overkill) implemented in test_hit_phase4_feedback + basic magnitude test_knockback_basic.

PHASE 5. Weapon Frame Overlay (Remove Slash Sheet Dependency)
Goal: Eliminate reliance on composite slash VFX spritesheet. Drive visual of weapon during attack strictly from 8 discrete per-frame PNGs + per-frame transform data.
5.1 Asset Convention: For weapon archetype <id>, expect PNGs:
	../assets/weapons/<id>_f0.png .. <id>_f7.png
	Missing file => fallback to nearest lower frame or f0 (warn once).
5.2 Pose JSON: ../assets/weapons/<id>_pose.json
	{
	  "weapon_id": <id>,
	  "frames": [ {"dx":0,"dy":0,"angle":0,"scale":1.0,"pivot_x":0.5,"pivot_y":0.5}, ... x8 ]
	}
	- dx,dy : pixel offsets relative to player torso origin / anchor.
	- angle : degrees (clockwise positive).
	- scale : uniform scalar.
	- pivot_x/pivot_y : normalized (0..1) weapon image space pivot for rotation.
5.3 Runtime Rendering: When attack animation frame i (0..7) active:
	- Select texture i; apply translation (dx,dy) + rotation around pivot + scale; render above player base sprite.
	- Slash arc effect deprecated; optional future procedural trail (deferred).
5.4 Procedural Trail (Deferred): Optionally compute weapon tip across previous N frames and draw additive poly strip (no authored assets).
5.5 Determinism: Frame index strictly derived from attack phase timer (integer division of elapsed_ms by frame_ms) for replay stability.
5.6 Tests: JSON load & pad (auto-add frames if <8), pivot correctness (unit harness checks rotated bounding box), deterministic frame advance.

Status: Done (runtime loader `weapon_pose.c/h`, integrated rendering overlay in `player_render.c`, unit test `test_weapon_pose_loader` validates JSON load & frame values, deterministic frame index derivation). Procedural trail (5.4) explicitly Deferred.

PHASE 5A. GUI Pose Authoring Tool
5A.1 Executable: weapon_pose_tool (SDL2). Inputs: --weapon <id> [--player-sheet path] [--out path]
5A.2 Loads single weapon image + player slash animation sheet (extracts 8 frames horizontally). Side-right frames reused mirrored for left in runtime.
5A.3 Controls:
	  Arrow keys: dx/dy ±1 (Shift: ±5)
	  Q/E: rotate ∓2° (Shift: 10°)
	  Z/X: scale -/+0.05
	  Ctrl+Arrow Left/Right: pivot_x -/+0.01
	  Ctrl+Arrow Up/Down: pivot_y -/+0.01
	  PageUp/PageDown or 1..8: select frame index
	  C: copy current frame transform
	  V: paste to current frame
	  S: save JSON (creates .bak)
	  Esc: quit
5A.4 HUD Text: frame index, dx, dy, angle, scale, pivot values; unsaved flag.
5A.5 Saving: Writes canonical JSON with 4-decimal floats, sorted keys; validates frame count.
5A.6 Logging: Warn missing PNGs, note fallback usage.
5A.7 Future: Batch export to CSV, drag with mouse, multi-weapon batch mode.
Status: Partial (Reworked `weapon_pose_tool`: single weapon image overlay across sliced 8 frames from a player sheet; per-frame dx/dy/angle/scale/pivot editing; auto PNG (WIC) or BMP load; HUD title shows current frame; JSON now records direction + frame_size. Still missing copy/paste, mouse drag, multi-direction batch, and left-mirror preview).

PHASE 6. Debug & Developer Tooling
6.1 Toggle key (F) sets g_app.show_hit_debug (implemented; reuses g_hit_debug_enabled).
6.2 Draw weapon capsule (cyan), impact points (yellow) and normals (lines) (implemented subset; enemy hurt AABBs deferred to Phase 7 integration pass to avoid duplication with other debug systems).
6.3 Text overlay shows frame id, hit count, player pos and tuning params (implemented). Knockback/explosion flags will be integrated after Phase 7 refactor (deferred).
6.4 Ring buffer playback deferred (not critical for initial debug value).
6.5 Tests: debug toggle flag unit test added (test_hit_phase6_debug_toggle). (Done)
Status: Partial-Done (core overlay + toggle + test delivered; remaining optional AABB & ring buffer deferred to later pass with legacy removal to prevent redundancy).

PHASE 7. Integration & Refactor of Legacy Logic
7.1 Remove old reach/arc calculation; replace strike damage trigger with weapon_sweep pipeline call.
7.2 Ensure combo / timing state machine unchanged (only hit detection swapped).
7.3 Update enemy death handling to branch explosion vs normal path.
7.4 Migrate existing knockback code to new magnitude function; deduplicate.
7.5 Adjust hitstop injection: apply only on first enemy hit each strike (cap multi-target slowdown).
7.6 Regression Tests: existing combat unit tests still pass (timings, crits, mitigation) + new sweep tests.
7.7 Performance check: profile per-frame sweep cost with 50 enemies; ensure <0.1ms average.

PHASE 8. Balancing & Tuning
8.1 Empirical tuning session: length vs width vs forgiveness; adjust width to avoid whiffs at point-blank.
8.2 Knockback scaling coefficients iteration (log differentials & resulting magnitudes).
8.3 Particle count & lifetime performance pass (avoid overdraw spikes).
8.4 Audio layering: add variation pool for impact (light/heavy/crit) if time permits.

PHASE 9. Documentation & Maintenance
9.1 Add docs/hit_system_overview.md (diagram of capsule vs enemy AABB intersection).
9.2 Add JSON schema comments for weapon geometry & overlay files.
9.3 Inline code comments for math helpers (closest point on segment, knockback scaling).
9.4 Add future hooks section (multi-hit weapons, charged sweep expansion, elemental impact FX).

RISK & MITIGATION
- Duplicate init paths (legacy app.c) could load outdated structs -> ensure single source integration.
- Performance regression with many enemies -> fallback to spatial grid if O(n) cost exceeds budget.
- Particle spam on multi-hit cleaves -> cap per strike global particle budget.
- Overlapping animation & geometry transforms -> validate pivot alignment early.

ESTIMATED ITERATION ORDER (SUGGESTED SLICES)
Slice 1: Phases 1–2 (geometry + capsule overlap core) + minimal debug.
Slice 2: Phase 3 + flash & knockback subset.
Slice 3: Particles + SFX + overkill explosion.
Slice 4: Slash VFX overlay & weapon transform table.
Slice 5: Full debug overlay & legacy removal.
Slice 6: Tests & tuning/balancing.

TEST MATRIX (Key Cases)
- Horizontal sweep hits single enemy at max reach.
- Diagonal sweep hits enemy off-axis within width tolerance.
- Multiple enemies clustered: all with centers intersecting capsule -> all register exactly once.
- Tiny enemy (small AABB) at edge still detected.
- High differential knockback vs equal-level minimal knockback.
- Overkill explosion vs normal kill (damage = max_health -1 then extra strike > threshold).
- Debug toggle on/off no behavior difference.
- Frame-rate variance (simulate dt jitter) still advances slash frames deterministically.

METRICS / LOGGING
- Log first N sweeps with: swing_id, enemies_hit, first_target_id, knockback_mag_avg.
- Counter of explosion deaths vs normal for balancing.
- Optional: histogram of miss distances (closest approach when no hit) for tuning width.

SUCCESS CRITERIA
- 100% existing combat tests pass + new hit system tests green.
- Visual: weapon contact matches perceived hits; minimal ghost whiffs.
- Performance: negligible frame time increase (<0.2ms @ 50 enemies).
- Feedback: distinct flash + particles + SFX on hit; explosion visually clear for one-shots.

STATUS SUMMARY
Phases 1–3: Done (geometry, runtime sweep, overlap + normals, per-strike mask, debug capture).
Phase 4: Done (refined knockback magnitude function, SFX stub, particle system w/ overkill burst, explosion flag, tests for magnitude & particle ranges).
Phase 5 (weapon frame overlay): Done (8-frame per-weapon pose system replaces slash sheet; JSON pose loader + textures + renderer integration; procedural trail deferred).
Phase 5A (pose authoring tool): Partial (keyboard-driven MVP saving JSON; lacks advanced features & PNG support).
Phase 6 (debug overlay): Partial-Done (capsule + hits + normals + text & toggle + test; AABB/explosion & ring buffer deferred).
Next: Phase 7 (legacy reach removal & perf profiling), Phase 8 (tuning), Phase 9 (documentation) then revisit deferred Phase 6 items & procedural trail.
